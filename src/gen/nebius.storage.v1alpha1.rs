// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transfer {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<TransferSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<TransferStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferSpec {
    #[prost(message, optional, tag="1")]
    pub source: ::core::option::Option<transfer_spec::SourceBucket>,
    #[prost(message, optional, tag="2")]
    pub destination: ::core::option::Option<transfer_spec::DestinationBucket>,
    /// Time to wait between transfer iterations. Default is 15 minutes if not specified.
    #[prost(message, optional, tag="6")]
    pub inter_iteration_interval: ::core::option::Option<::pbjson_types::Duration>,
    /// Overwrite strategy set logic of overwrite already existed objects in destination bucket.
    #[prost(enumeration="transfer_spec::OverwriteStrategy", tag="7")]
    pub overwrite_strategy: i32,
    /// The stop condition is checked after every iteration. If the condition is met, the transfer will stop.
    #[prost(oneof="transfer_spec::StopCondition", tags="3, 4, 5")]
    pub stop_condition: ::core::option::Option<transfer_spec::StopCondition>,
}
/// Nested message and enum types in `TransferSpec`.
pub mod transfer_spec {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SourceBucket {
        /// The endpoint must be in the form of a URL, starting with the protocol (https),
        /// followed by the endpoint address without a trailing slash.
        /// Example: <https://storage.us-central1.nebius.cloud>
        #[prost(string, tag="1")]
        pub endpoint: ::prost::alloc::string::String,
        #[prost(string, tag="2")]
        pub bucket_name: ::prost::alloc::string::String,
        #[prost(string, tag="3")]
        pub region: ::prost::alloc::string::String,
        /// Credentials for accessing the source bucket. These credentials must have list and get permissions.
        /// This parameter must be specified only during create operations.
        #[prost(message, optional, tag="4")]
        pub credentials: ::core::option::Option<BucketCredentials>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DestinationBucket {
        #[prost(string, tag="1")]
        pub bucket_name: ::prost::alloc::string::String,
        /// Credentials for accessing the destination bucket. These credentials must have head and write permissions.
        /// This parameter must be specified only during create operations.
        #[prost(message, optional, tag="2")]
        pub credentials: ::core::option::Option<BucketCredentials>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BucketCredentials {
        #[prost(oneof="bucket_credentials::Credentials", tags="1, 2")]
        pub credentials: ::core::option::Option<bucket_credentials::Credentials>,
    }
    /// Nested message and enum types in `BucketCredentials`.
    pub mod bucket_credentials {
        #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct CredentialsAnonymous {
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CredentialsAccessKey {
            #[prost(string, tag="1")]
            pub access_key_id: ::prost::alloc::string::String,
            #[prost(string, tag="2")]
            pub secret_access_key: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Credentials {
            #[prost(message, tag="1")]
            Anonymous(CredentialsAnonymous),
            #[prost(message, tag="2")]
            AccessKey(CredentialsAccessKey),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct StopConditionAfterOneIteration {
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct StopConditionAfterNEmptyIterations {
        /// Number of consecutive iterations with zero transferred objects required to stop transfer.
        #[prost(uint32, tag="1")]
        pub empty_iterations_threshold: u32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct StopConditionInfinite {
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum OverwriteStrategy {
        Unspecified = 0,
        /// Never overwrite objects that exist in the destination.
        /// If object exists in destination bucket, skip it.
        /// Safest option to prevent data loss.
        Never = 1,
        /// Overwrite only if source object is newer than destination.
        /// Comparison based on Last-Modified timestamp.
        /// Recommended for incremental sync scenarios.
        IfNewer = 2,
        /// Always overwrite destination objects unconditionally.
        /// Use with caution - may cause data loss in destination.
        /// Suitable for full bucket synchronization.
        Always = 3,
    }
    impl OverwriteStrategy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OverwriteStrategy::Unspecified => "OVERWRITE_STRATEGY_UNSPECIFIED",
                OverwriteStrategy::Never => "NEVER",
                OverwriteStrategy::IfNewer => "IF_NEWER",
                OverwriteStrategy::Always => "ALWAYS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OVERWRITE_STRATEGY_UNSPECIFIED" => Some(Self::Unspecified),
                "NEVER" => Some(Self::Never),
                "IF_NEWER" => Some(Self::IfNewer),
                "ALWAYS" => Some(Self::Always),
                _ => None,
            }
        }
    }
    /// The stop condition is checked after every iteration. If the condition is met, the transfer will stop.
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum StopCondition {
        #[prost(message, tag="3")]
        AfterOneIteration(StopConditionAfterOneIteration),
        #[prost(message, tag="4")]
        AfterNEmptyIterations(StopConditionAfterNEmptyIterations),
        /// Infinite transfers do not stop automatically and can be stopped manually by the user.
        #[prost(message, tag="5")]
        Infinite(StopConditionInfinite),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferStatus {
    #[prost(enumeration="transfer_status::State", tag="1")]
    pub state: i32,
    /// Error information if the transfer has failed.
    #[prost(string, tag="2")]
    pub error: ::prost::alloc::string::String,
    #[prost(enumeration="transfer_status::SuspensionState", tag="3")]
    pub suspension_state: i32,
    #[prost(message, optional, tag="4")]
    pub last_iteration: ::core::option::Option<TransferIteration>,
}
/// Nested message and enum types in `TransferStatus`.
pub mod transfer_status {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Stopping = 2,
        Stopped = 3,
        Failing = 4,
        Failed = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::Stopping => "STOPPING",
                State::Stopped => "STOPPED",
                State::Failing => "FAILING",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "STOPPING" => Some(Self::Stopping),
                "STOPPED" => Some(Self::Stopped),
                "FAILING" => Some(Self::Failing),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SuspensionState {
        Unspecified = 0,
        NotSuspended = 1,
        Suspended = 2,
    }
    impl SuspensionState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SuspensionState::Unspecified => "SUSPENSION_STATE_UNSPECIFIED",
                SuspensionState::NotSuspended => "NOT_SUSPENDED",
                SuspensionState::Suspended => "SUSPENDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SUSPENSION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "NOT_SUSPENDED" => Some(Self::NotSuspended),
                "SUSPENDED" => Some(Self::Suspended),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferIteration {
    #[prost(int64, tag="1")]
    pub sequence_number: i64,
    #[prost(enumeration="transfer_iteration::State", tag="2")]
    pub state: i32,
    /// Human-readable error description. Populated only if state is FAILED.
    #[prost(string, tag="3")]
    pub error: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub start_time: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(message, optional, tag="5")]
    pub end_time: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(int64, tag="6")]
    pub objects_discovered_count: i64,
    #[prost(int64, tag="7")]
    pub objects_migrated_count: i64,
    #[prost(int64, tag="8")]
    pub objects_skipped_count: i64,
    #[prost(int64, tag="9")]
    pub objects_migrated_size: i64,
    #[prost(int64, tag="10")]
    pub average_throughput_bytes: i64,
}
/// Nested message and enum types in `TransferIteration`.
pub mod transfer_iteration {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        InProgress = 1,
        Completed = 2,
        Stopped = 3,
        Failed = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::InProgress => "IN_PROGRESS",
                State::Completed => "COMPLETED",
                State::Stopped => "STOPPED",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "IN_PROGRESS" => Some(Self::InProgress),
                "COMPLETED" => Some(Self::Completed),
                "STOPPED" => Some(Self::Stopped),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransferRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTransfersRequest {
    /// Represents the container ID.
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// Specifies the maximum number of items to return in the response.
    #[prost(int64, tag="2")]
    pub page_size: i64,
    /// Token for pagination, allowing the retrieval of the next set of results.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTransfersResponse {
    /// List of transfers returned in the response.
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Transfer>,
    /// Token for pagination, indicating the next set of results can be retrieved using this token.
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTransferRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<TransferSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTransferRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<TransferSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopTransferRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResumeTransferRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTransferRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub resource_version: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIterationHistoryRequest {
    #[prost(string, tag="1")]
    pub transfer_id: ::prost::alloc::string::String,
    /// Specifies the maximum number of items to return in the response.
    #[prost(int64, tag="2")]
    pub page_size: i64,
    /// Token for pagination, allowing the retrieval of the next set of results.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIterationHistoryResponse {
    /// List of transfer iterations sorted from newest to oldest.
    #[prost(message, repeated, tag="1")]
    pub iterations: ::prost::alloc::vec::Vec<TransferIteration>,
    /// Token for pagination, indicating the next set of results can be retrieved using this token.
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
include!("nebius.storage.v1alpha1.serde.rs");
include!("nebius.storage.v1alpha1.tonic.rs");
// @@protoc_insertion_point(module)