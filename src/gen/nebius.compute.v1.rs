// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Disk {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<DiskSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<DiskStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskSpec {
    /// Block size in bytes.
    /// The block size must be a power of two between 4096 bytes (4 KiB) and 131072 bytes (128 KiB).
    /// The default value is 4096 bytes (4 KiB).
    #[prost(int64, tag="5")]
    pub block_size_bytes: i64,
    /// The type of disk defines the performance and reliability characteristics of the block device.
    /// For details, see <https://docs.nebius.com/compute/storage/types#disks-types>
    #[prost(enumeration="disk_spec::DiskType", tag="6")]
    pub r#type: i32,
    #[prost(message, optional, tag="7")]
    pub placement_policy: ::core::option::Option<DiskPlacementPolicy>,
    /// Size of the disk. The size must be within the limits for the selected disk type.
    /// For current limits, see <https://docs.nebius.com/compute/storage/types#disks-types-comparison>
    #[prost(oneof="disk_spec::Size", tags="1, 2, 3, 4")]
    pub size: ::core::option::Option<disk_spec::Size>,
    /// Source for disk creation.
    /// Boot disk must be created from an image <https://docs.nebius.com/compute/storage/manage#boot>
    /// Additional disks can be created as an empty volume <https://docs.nebius.com/compute/storage/manage#additional>
    #[prost(oneof="disk_spec::Source", tags="8, 10")]
    pub source: ::core::option::Option<disk_spec::Source>,
}
/// Nested message and enum types in `DiskSpec`.
pub mod disk_spec {
    /// the list of available types will be clarified later, it is not final version
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum DiskType {
        Unspecified = 0,
        NetworkSsd = 1,
        NetworkHdd = 2,
        NetworkSsdNonReplicated = 3,
        NetworkSsdIoM3 = 4,
    }
    impl DiskType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DiskType::Unspecified => "UNSPECIFIED",
                DiskType::NetworkSsd => "NETWORK_SSD",
                DiskType::NetworkHdd => "NETWORK_HDD",
                DiskType::NetworkSsdNonReplicated => "NETWORK_SSD_NON_REPLICATED",
                DiskType::NetworkSsdIoM3 => "NETWORK_SSD_IO_M3",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "NETWORK_SSD" => Some(Self::NetworkSsd),
                "NETWORK_HDD" => Some(Self::NetworkHdd),
                "NETWORK_SSD_NON_REPLICATED" => Some(Self::NetworkSsdNonReplicated),
                "NETWORK_SSD_IO_M3" => Some(Self::NetworkSsdIoM3),
                _ => None,
            }
        }
    }
    /// Size of the disk. The size must be within the limits for the selected disk type.
    /// For current limits, see <https://docs.nebius.com/compute/storage/types#disks-types-comparison>
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Size {
        #[prost(int64, tag="1")]
        SizeBytes(i64),
        #[prost(int64, tag="2")]
        SizeKibibytes(i64),
        #[prost(int64, tag="3")]
        SizeMebibytes(i64),
        #[prost(int64, tag="4")]
        SizeGibibytes(i64),
    }
    /// Source for disk creation.
    /// Boot disk must be created from an image <https://docs.nebius.com/compute/storage/manage#boot>
    /// Additional disks can be created as an empty volume <https://docs.nebius.com/compute/storage/manage#additional>
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(string, tag="8")]
        SourceImageId(::prost::alloc::string::String),
        #[prost(message, tag="10")]
        SourceImageFamily(super::SourceImageFamily),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceImageFamily {
    #[prost(string, tag="1")]
    pub image_family: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub parent_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskPlacementPolicy {
    #[prost(string, tag="1")]
    pub placement_group_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub placement_group_partition: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskStatus {
    #[prost(enumeration="disk_status::State", tag="1")]
    pub state: i32,
    #[prost(string, tag="2")]
    pub state_description: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub read_write_attachment: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="4")]
    pub read_only_attachments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="5")]
    pub source_image_id: ::prost::alloc::string::String,
    #[prost(int64, tag="6")]
    pub size_bytes: i64,
    /// Indicates whether there is an ongoing operation
    #[prost(bool, tag="7")]
    pub reconciling: bool,
    #[prost(int64, tag="8")]
    pub block_size_bytes: i64,
    #[prost(enumeration="disk_status::SourceImageCpuArchitecture", tag="9")]
    pub source_image_cpu_architecture: i32,
}
/// Nested message and enum types in `DiskStatus`.
pub mod disk_status {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        Ready = 2,
        Updating = 3,
        Deleting = 4,
        Error = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "UNSPECIFIED",
                State::Creating => "CREATING",
                State::Ready => "READY",
                State::Updating => "UPDATING",
                State::Deleting => "DELETING",
                State::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "READY" => Some(Self::Ready),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SourceImageCpuArchitecture {
        SourceImageCpuUnspecified = 0,
        Amd64 = 1,
        Arm64 = 2,
    }
    impl SourceImageCpuArchitecture {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SourceImageCpuArchitecture::SourceImageCpuUnspecified => "SOURCE_IMAGE_CPU_UNSPECIFIED",
                SourceImageCpuArchitecture::Amd64 => "AMD64",
                SourceImageCpuArchitecture::Arm64 => "ARM64",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SOURCE_IMAGE_CPU_UNSPECIFIED" => Some(Self::SourceImageCpuUnspecified),
                "AMD64" => Some(Self::Amd64),
                "ARM64" => Some(Self::Arm64),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOperationsByParentRequest {
    /// ID of the parent to list operations for resource type at.
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// Page size. \[1...1000\]. Optional, if not specified, a reasonable default will be chosen by the service.
    #[prost(int64, tag="2")]
    pub page_size: i64,
    /// Listing continuation token. Empty to start listing from the first page.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDiskRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDisksRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDiskRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<DiskSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDiskRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<DiskSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDiskRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDisksResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Disk>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Filesystem {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<FilesystemSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<FilesystemStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FilesystemSpec {
    /// Block size in bytes.
    /// The block size must be a power of two between 4096 bytes (4 KiB) and 131072 bytes (128 KiB).
    /// The default value is 4096 bytes (4 KiB).
    #[prost(int64, tag="5")]
    pub block_size_bytes: i64,
    /// The Shared Filesystem type determines its limits and performance characteristics.
    /// For details, see <https://docs.nebius.com/compute/storage/types#filesystems-types>
    #[prost(enumeration="filesystem_spec::FilesystemType", tag="6")]
    pub r#type: i32,
    /// Size of the disk. Only one size unit can be specified.
    /// The size must be within the limits for the selected disk type.
    /// For current limits, see <https://docs.nebius.com/compute/storage/types#disks-types-comparison>
    #[prost(oneof="filesystem_spec::Size", tags="1, 2, 3, 4")]
    pub size: ::core::option::Option<filesystem_spec::Size>,
}
/// Nested message and enum types in `FilesystemSpec`.
pub mod filesystem_spec {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum FilesystemType {
        Unspecified = 0,
        /// the list of available types will be clarified later, it is not final version
        NetworkSsd = 1,
        NetworkHdd = 2,
    }
    impl FilesystemType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FilesystemType::Unspecified => "UNSPECIFIED",
                FilesystemType::NetworkSsd => "NETWORK_SSD",
                FilesystemType::NetworkHdd => "NETWORK_HDD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "NETWORK_SSD" => Some(Self::NetworkSsd),
                "NETWORK_HDD" => Some(Self::NetworkHdd),
                _ => None,
            }
        }
    }
    /// Size of the disk. Only one size unit can be specified.
    /// The size must be within the limits for the selected disk type.
    /// For current limits, see <https://docs.nebius.com/compute/storage/types#disks-types-comparison>
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Size {
        #[prost(int64, tag="1")]
        SizeBytes(i64),
        #[prost(int64, tag="2")]
        SizeKibibytes(i64),
        #[prost(int64, tag="3")]
        SizeMebibytes(i64),
        #[prost(int64, tag="4")]
        SizeGibibytes(i64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilesystemStatus {
    #[prost(enumeration="filesystem_status::State", tag="1")]
    pub state: i32,
    #[prost(string, tag="2")]
    pub state_description: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="3")]
    pub read_write_attachments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="4")]
    pub read_only_attachments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag="5")]
    pub size_bytes: i64,
    /// Indicates whether there is an ongoing operation
    #[prost(bool, tag="6")]
    pub reconciling: bool,
    #[prost(int64, tag="7")]
    pub block_size_bytes: i64,
}
/// Nested message and enum types in `FilesystemStatus`.
pub mod filesystem_status {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        Ready = 2,
        Updating = 3,
        Deleting = 4,
        Error = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "UNSPECIFIED",
                State::Creating => "CREATING",
                State::Ready => "READY",
                State::Updating => "UPDATING",
                State::Deleting => "DELETING",
                State::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "READY" => Some(Self::Ready),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilesystemRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFilesystemsRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFilesystemRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<FilesystemSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFilesystemRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<FilesystemSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFilesystemRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFilesystemsResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Filesystem>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuCluster {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<GpuClusterSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<GpuClusterStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuClusterSpec {
    /// The identifier of the physical InfiniBand fabric to connect GPU instances to.
    /// For details, see <https://docs.nebius.com/compute/clusters/gpu#fabrics>
    #[prost(string, tag="1")]
    pub infiniband_fabric: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuClusterStatus {
    #[prost(string, repeated, tag="1")]
    pub instances: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Indicates whether there is an ongoing operation
    #[prost(bool, tag="2")]
    pub reconciling: bool,
    #[prost(oneof="gpu_cluster_status::Topology", tags="3")]
    pub topology: ::core::option::Option<gpu_cluster_status::Topology>,
}
/// Nested message and enum types in `GpuClusterStatus`.
pub mod gpu_cluster_status {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Topology {
        #[prost(message, tag="3")]
        InfinibandTopologyPath(super::GpuClusterStatusInfinibandTopologyPath),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuClusterStatusInfinibandTopologyPath {
    #[prost(message, repeated, tag="1")]
    pub instances: ::prost::alloc::vec::Vec<GpuClusterStatusInfinibandTopologyPathInstance>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuClusterStatusInfinibandTopologyPathInstance {
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="2")]
    pub path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGpuClusterRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGpuClustersRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateGpuClusterRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<GpuClusterSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateGpuClusterRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<GpuClusterSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteGpuClusterRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGpuClustersResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<GpuCluster>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Image {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<ImageSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<ImageStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageSpec {
    #[prost(string, optional, tag="1")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag="2")]
    pub image_family: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub version: ::prost::alloc::string::String,
    #[prost(enumeration="image_spec::CpuArchitecture", tag="6")]
    pub cpu_architecture: i32,
}
/// Nested message and enum types in `ImageSpec`.
pub mod image_spec {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum CpuArchitecture {
        Unspecified = 0,
        Amd64 = 1,
        Arm64 = 2,
    }
    impl CpuArchitecture {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CpuArchitecture::Unspecified => "UNSPECIFIED",
                CpuArchitecture::Amd64 => "AMD64",
                CpuArchitecture::Arm64 => "ARM64",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "AMD64" => Some(Self::Amd64),
                "ARM64" => Some(Self::Arm64),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageStatus {
    #[prost(enumeration="image_status::State", tag="1")]
    pub state: i32,
    #[prost(string, tag="2")]
    pub state_description: ::prost::alloc::string::String,
    #[prost(int64, tag="3")]
    pub storage_size_bytes: i64,
    #[prost(int64, tag="4")]
    pub min_disk_size_bytes: i64,
    /// Indicates whether there is an ongoing operation
    #[prost(bool, tag="5")]
    pub reconciling: bool,
}
/// Nested message and enum types in `ImageStatus`.
pub mod image_status {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        Ready = 2,
        Updating = 3,
        Deleting = 4,
        Error = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "UNSPECIFIED",
                State::Creating => "CREATING",
                State::Ready => "READY",
                State::Updating => "UPDATING",
                State::Deleting => "DELETING",
                State::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "READY" => Some(Self::Ready),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetImageRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetImageLatestByFamilyRequest {
    #[prost(string, tag="1")]
    pub image_family: ::prost::alloc::string::String,
    /// default 'project-{region}public-images'
    #[prost(string, tag="2")]
    pub parent_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListImagesRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListImagesResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Image>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Describes the specification of a network interface.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkInterfaceSpec {
    /// Subnet ID
    #[prost(string, tag="1")]
    pub subnet_id: ::prost::alloc::string::String,
    /// Interface name
    /// Value of this field configures the name of the network interface inside VM's OS.
    /// Longer values will persist in the specification but will be truncated to 15 symbols before being passed to VM configuration.
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    /// Private IPv4 address associated with the interface.
    #[prost(message, optional, tag="3")]
    pub ip_address: ::core::option::Option<IpAddress>,
    /// Public IPv4 address associated with the interface.
    #[prost(message, optional, tag="4")]
    pub public_ip_address: ::core::option::Option<PublicIpAddress>,
}
/// Describes an IPv4 address.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpAddress {
    /// Allocation identifier if it was created before.
    #[prost(string, tag="1")]
    pub allocation_id: ::prost::alloc::string::String,
}
/// Describes a public IP address.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicIpAddress {
    /// If false - Allocation will be created/deleted during NetworkInterface.Allocate/NetworkInterface.Deallocate
    /// If true  - Allocation will be created/deleted during NetworkInterface.Create/NetworkInterface.Delete
    /// False by default
    #[prost(bool, tag="3")]
    pub r#static: bool,
    /// Describes different methods of public IP address allocation.
    #[prost(oneof="public_ip_address::Allocation", tags="1")]
    pub allocation: ::core::option::Option<public_ip_address::Allocation>,
}
/// Nested message and enum types in `PublicIPAddress`.
pub mod public_ip_address {
    /// Describes different methods of public IP address allocation.
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Allocation {
        /// Allocation identifier if it was created before.
        #[prost(string, tag="1")]
        AllocationId(::prost::alloc::string::String),
    }
}
/// Describes the status of a network interface.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkInterfaceStatus {
    /// The index of the network interface
    #[prost(int32, tag="1")]
    pub index: i32,
    /// Name for interface.
    /// Unique within instance's network interfaces
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    /// Effective Private IPv4 address
    #[prost(message, optional, tag="3")]
    pub ip_address: ::core::option::Option<IpAddressStatus>,
    /// Effective Public IPv4 address
    #[prost(message, optional, tag="4")]
    pub public_ip_address: ::core::option::Option<PublicIpAddressStatus>,
    /// MAC address
    #[prost(string, tag="7")]
    pub mac_address: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpAddressStatus {
    /// Effective private IPv4 address assigned to the interface.
    #[prost(string, tag="1")]
    pub address: ::prost::alloc::string::String,
    /// Allocation identifier.
    #[prost(string, tag="2")]
    pub allocation_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicIpAddressStatus {
    /// Effective public IPv4 address assigned to the interface.
    #[prost(string, tag="1")]
    pub address: ::prost::alloc::string::String,
    /// Allocation identifier.
    #[prost(string, tag="2")]
    pub allocation_id: ::prost::alloc::string::String,
    /// If false - Allocation will be created/deleted during NetworkInterface.Allocate/NetworkInterface.Deallocate
    /// If true  - Allocation will be created/deleted during NetworkInterface.Create/NetworkInterface.Delete
    /// False by default
    #[prost(bool, tag="3")]
    pub r#static: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Instance {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<InstanceSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<InstanceStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceSpec {
    /// Unique identifier of the service account associated with this instance.
    /// For details, see <https://docs.nebius.dev/en/iam/about-iam/concepts/service-accounts>
    #[prost(string, tag="1")]
    pub service_account_id: ::prost::alloc::string::String,
    /// Specification of compute resources allocated to the instance.
    /// For details, see <https://docs.nebius.com/compute/virtual-machines/types>
    #[prost(message, optional, tag="2")]
    pub resources: ::core::option::Option<ResourcesSpec>,
    /// If you want to interconnect several instances in a GPU cluster via NVIDIA InfiniBand,
    /// set the ID of an existing GPU cluster.
    /// You can only add the VM to the cluster when creating the VM.
    /// For details, see <https://docs.nebius.com/compute/clusters/gpu>
    #[prost(message, optional, tag="3")]
    pub gpu_cluster: ::core::option::Option<InstanceGpuClusterSpec>,
    /// List of network interfaces attached to the instance.
    #[prost(message, repeated, tag="4")]
    pub network_interfaces: ::prost::alloc::vec::Vec<NetworkInterfaceSpec>,
    /// Specified boot disk attached to the instance.
    #[prost(message, optional, tag="5")]
    pub boot_disk: ::core::option::Option<AttachedDiskSpec>,
    /// List of additional data disks attached to the instance beyond the boot disk.
    #[prost(message, repeated, tag="6")]
    pub secondary_disks: ::prost::alloc::vec::Vec<AttachedDiskSpec>,
    /// List of Shared Filesystems attached to the instance.
    #[prost(message, repeated, tag="7")]
    pub filesystems: ::prost::alloc::vec::Vec<AttachedFilesystemSpec>,
    /// Data in cloud-init format for customizing instance initialization.
    /// For details, see <https://docs.nebius.com/compute/virtual-machines/manage#user-data>
    #[prost(string, tag="8")]
    pub cloud_init_user_data: ::prost::alloc::string::String,
    /// Indicates whether the instance should be stopped.
    #[prost(bool, tag="13")]
    pub stopped: bool,
    /// Recovery policy defines how the instance will be treated in case of a failure. Common source of failure is a host failure, but it can be any other failure.
    /// Instance undergoing a guest shutdown (poweroff, etc.) will be subject to recovery policy, meaning that it could be restarted and billed accordingly. Stop instance via API or UI to stop it to avoid recovering.
    /// If set to RECOVER, instance will be restarted, if possible. It could be restarted on the same host or on another host.
    /// If set to FAIL, instance will be stopped and not restarted.
    #[prost(enumeration="InstanceRecoveryPolicy", tag="15")]
    pub recovery_policy: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcesSpec {
    #[prost(string, tag="1")]
    pub platform: ::prost::alloc::string::String,
    #[prost(oneof="resources_spec::Size", tags="2")]
    pub size: ::core::option::Option<resources_spec::Size>,
}
/// Nested message and enum types in `ResourcesSpec`.
pub mod resources_spec {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Size {
        #[prost(string, tag="2")]
        Preset(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGpuClusterSpec {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachedDiskSpec {
    #[prost(enumeration="attached_disk_spec::AttachMode", tag="1")]
    pub attach_mode: i32,
    /// Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_id}' as a device path in mount command.
    #[prost(string, tag="3")]
    pub device_id: ::prost::alloc::string::String,
    #[prost(oneof="attached_disk_spec::Type", tags="2")]
    pub r#type: ::core::option::Option<attached_disk_spec::Type>,
}
/// Nested message and enum types in `AttachedDiskSpec`.
pub mod attached_disk_spec {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum AttachMode {
        Unspecified = 0,
        ReadOnly = 1,
        ReadWrite = 2,
    }
    impl AttachMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AttachMode::Unspecified => "UNSPECIFIED",
                AttachMode::ReadOnly => "READ_ONLY",
                AttachMode::ReadWrite => "READ_WRITE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "READ_ONLY" => Some(Self::ReadOnly),
                "READ_WRITE" => Some(Self::ReadWrite),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag="2")]
        ExistingDisk(super::ExistingDisk),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExistingDisk {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExistingFilesystem {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachedFilesystemSpec {
    #[prost(enumeration="attached_filesystem_spec::AttachMode", tag="1")]
    pub attach_mode: i32,
    /// Specifies the user-defined identifier, allowing to use it as a device in mount command.
    #[prost(string, tag="2")]
    pub mount_tag: ::prost::alloc::string::String,
    #[prost(oneof="attached_filesystem_spec::Type", tags="3")]
    pub r#type: ::core::option::Option<attached_filesystem_spec::Type>,
}
/// Nested message and enum types in `AttachedFilesystemSpec`.
pub mod attached_filesystem_spec {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum AttachMode {
        Unspecified = 0,
        ReadOnly = 1,
        ReadWrite = 2,
    }
    impl AttachMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AttachMode::Unspecified => "UNSPECIFIED",
                AttachMode::ReadOnly => "READ_ONLY",
                AttachMode::ReadWrite => "READ_WRITE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "READ_ONLY" => Some(Self::ReadOnly),
                "READ_WRITE" => Some(Self::ReadWrite),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag="3")]
        ExistingFilesystem(super::ExistingFilesystem),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceStatus {
    #[prost(enumeration="instance_status::InstanceState", tag="1")]
    pub state: i32,
    #[prost(message, repeated, tag="2")]
    pub network_interfaces: ::prost::alloc::vec::Vec<NetworkInterfaceStatus>,
    /// Indicates whether there is an ongoing operation
    #[prost(bool, tag="5")]
    pub reconciling: bool,
    #[prost(string, tag="7")]
    pub maintenance_event_id: ::prost::alloc::string::String,
    #[prost(oneof="instance_status::GpuClusterTopology", tags="10")]
    pub gpu_cluster_topology: ::core::option::Option<instance_status::GpuClusterTopology>,
}
/// Nested message and enum types in `InstanceStatus`.
pub mod instance_status {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum InstanceState {
        Unspecified = 0,
        Creating = 1,
        Updating = 2,
        Starting = 3,
        Running = 4,
        Stopping = 5,
        Stopped = 6,
        Deleting = 7,
        Error = 8,
    }
    impl InstanceState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InstanceState::Unspecified => "UNSPECIFIED",
                InstanceState::Creating => "CREATING",
                InstanceState::Updating => "UPDATING",
                InstanceState::Starting => "STARTING",
                InstanceState::Running => "RUNNING",
                InstanceState::Stopping => "STOPPING",
                InstanceState::Stopped => "STOPPED",
                InstanceState::Deleting => "DELETING",
                InstanceState::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "UPDATING" => Some(Self::Updating),
                "STARTING" => Some(Self::Starting),
                "RUNNING" => Some(Self::Running),
                "STOPPING" => Some(Self::Stopping),
                "STOPPED" => Some(Self::Stopped),
                "DELETING" => Some(Self::Deleting),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum GpuClusterTopology {
        #[prost(message, tag="10")]
        InfinibandTopologyPath(super::InstanceStatusInfinibandTopologyPath),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceStatusInfinibandTopologyPath {
    #[prost(string, repeated, tag="1")]
    pub path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InstanceRecoveryPolicy {
    Recover = 0,
    Fail = 1,
}
impl InstanceRecoveryPolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            InstanceRecoveryPolicy::Recover => "RECOVER",
            InstanceRecoveryPolicy::Fail => "FAIL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RECOVER" => Some(Self::Recover),
            "FAIL" => Some(Self::Fail),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInstanceRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstancesRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInstanceRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<InstanceSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInstanceRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<InstanceSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInstanceRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstancesResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Instance>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartInstanceRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopInstanceRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeSetUnhealthyRequest {
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub health_check_info: ::core::option::Option<node_set_unhealthy_request::HealthCheckInfo>,
}
/// Nested message and enum types in `NodeSetUnhealthyRequest`.
pub mod node_set_unhealthy_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct HealthCheckInfo {
        /// Time when the unhealthy node was observed
        #[prost(message, optional, tag="1")]
        pub observed_at: ::core::option::Option<::pbjson_types::Timestamp>,
        /// Identifies specific GPU check that failed in soperator (key for observability)
        #[prost(string, tag="2")]
        pub check_id: ::prost::alloc::string::String,
        /// Human-readable description of the error for further investigation
        #[prost(string, tag="3")]
        pub description: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NodeSetUnhealthyResponse {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Platform {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<PlatformSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<PlatformStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlatformSpec {
    #[prost(message, repeated, tag="1")]
    pub presets: ::prost::alloc::vec::Vec<Preset>,
    #[prost(string, tag="3")]
    pub gpu_count_quota_type: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub human_readable_name: ::prost::alloc::string::String,
    #[prost(bool, tag="5")]
    pub allow_preset_change: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Preset {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub resources: ::core::option::Option<PresetResources>,
    #[prost(bool, tag="3")]
    pub allow_gpu_clustering: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PresetResources {
    #[prost(int32, tag="1")]
    pub vcpu_count: i32,
    #[prost(int32, tag="3")]
    pub memory_gibibytes: i32,
    #[prost(int32, tag="4")]
    pub gpu_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlatformStatus {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPlatformsRequest {
    #[prost(int64, tag="1")]
    pub page_size: i64,
    #[prost(string, tag="2")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub parent_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPlatformsResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Platform>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
include!("nebius.compute.v1.serde.rs");
include!("nebius.compute.v1.tonic.rs");
// @@protoc_insertion_point(module)