// @generated
// This file is @generated by prost-build.
/// Describes the specification of a network interface.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkInterfaceSpec {
    /// Subnet ID
    #[prost(string, tag="1")]
    pub subnet_id: ::prost::alloc::string::String,
    /// Interface name
    /// Value of this field configures the name of the network interface inside VM's OS.
    /// Longer values will persist in the specification but will be truncated to 15 symbols before being passed to VM configuration.
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    /// Private IPv4 address associated with the interface.
    #[prost(message, optional, tag="3")]
    pub ip_address: ::core::option::Option<IpAddress>,
    /// Public IPv4 address associated with the interface.
    #[prost(message, optional, tag="4")]
    pub public_ip_address: ::core::option::Option<PublicIpAddress>,
}
/// Describes an IPv4 address.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpAddress {
    /// Allocation identifier if it was created before.
    #[prost(string, tag="1")]
    pub allocation_id: ::prost::alloc::string::String,
}
/// Describes a public IP address.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicIpAddress {
    /// If false - Lifecycle of allocation depends on NetworkInterface.Allocate/NetworkInterface.Deallocate
    /// If true  - Lifecycle of allocation depends on NetworkInterface.Create/NetworkInterface.Delete
    /// False by default
    #[prost(bool, tag="3")]
    pub r#static: bool,
    /// Describes different methods of public IP address allocation.
    #[prost(oneof="public_ip_address::Allocation", tags="1")]
    pub allocation: ::core::option::Option<public_ip_address::Allocation>,
}
/// Nested message and enum types in `PublicIPAddress`.
pub mod public_ip_address {
    /// Describes different methods of public IP address allocation.
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Allocation {
        /// Allocation identifier if it was created before.
        #[prost(string, tag="1")]
        AllocationId(::prost::alloc::string::String),
    }
}
/// Describes the status of a network interface.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkInterfaceStatus {
    /// The index of the network interface
    #[prost(int32, tag="1")]
    pub index: i32,
    /// Name for interface.
    /// Unique within instance's network interfaces
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    /// Effective Private IPv4 address
    #[prost(message, optional, tag="3")]
    pub ip_address: ::core::option::Option<IpAddressStatus>,
    /// Effective Public IPv4 address
    #[prost(message, optional, tag="4")]
    pub public_ip_address: ::core::option::Option<PublicIpAddressStatus>,
    /// MAC address
    #[prost(string, tag="7")]
    pub mac_address: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpAddressStatus {
    /// Effective private IPv4 address assigned to the interface.
    #[prost(string, tag="1")]
    pub address: ::prost::alloc::string::String,
    /// Allocation identifier.
    #[prost(string, tag="2")]
    pub allocation_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicIpAddressStatus {
    /// Effective public IPv4 address assigned to the interface.
    #[prost(string, tag="1")]
    pub address: ::prost::alloc::string::String,
    /// Allocation identifier.
    #[prost(string, tag="2")]
    pub allocation_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Pool {
    /// Metadata associated with the Pool.
    /// `metadata.parent_id` represents the Project.
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    /// Specification of the Pool.
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<PoolSpec>,
    /// Status information for the Pool.
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<PoolStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PoolSpec {
    /// IP version for the Pool.
    #[prost(enumeration="IpVersion", tag="3")]
    pub version: i32,
    /// CIDR blocks.
    #[prost(message, repeated, tag="4")]
    pub cidrs: ::prost::alloc::vec::Vec<PoolCidr>,
    #[prost(oneof="pool_spec::Source", tags="1, 2")]
    pub source: ::core::option::Option<pool_spec::Source>,
}
/// Nested message and enum types in `PoolSpec`.
pub mod pool_spec {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// ID of source pool. Current pool will be created with the same scope.
        #[prost(string, tag="1")]
        SourcePoolId(::prost::alloc::string::String),
        /// ID of the scope. Pool will be considered as top-level pool within scope.
        #[prost(string, tag="2")]
        SourceScopeId(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PoolCidr {
    /// CIDR block.
    /// May be a prefix length (such as /24) for non-top-level pools
    /// or a CIDR-formatted string (such as 10.1.2.0/24).
    #[prost(string, tag="1")]
    pub cidr: ::prost::alloc::string::String,
    /// State of the Cidr.
    #[prost(enumeration="PoolCidrState", tag="2")]
    pub state: i32,
    /// Maximum mask length for allocation from this IP pool including creation of sub-pools
    #[prost(int64, tag="3")]
    pub allowed_mask: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PoolStatus {
    /// Current state of the Pool.
    #[prost(enumeration="pool_status::State", tag="1")]
    pub state: i32,
    /// CIDR blocks.
    #[prost(string, repeated, tag="2")]
    pub cidrs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// ID of the scope
    #[prost(string, tag="3")]
    pub scope_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `PoolStatus`.
pub mod pool_status {
    /// Possible states of the Pool.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        /// Default, unspecified state.
        Unspecified = 0,
        /// Pool is being created.
        Creating = 1,
        /// Pool is ready for use.
        Ready = 2,
        /// Pool is being deleted.
        Deleting = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Ready => "READY",
                State::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "READY" => Some(Self::Ready),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PoolCidrState {
    /// Default, unspecified state.
    StateUnspecified = 0,
    /// Allocation from range is available.
    Available = 1,
    /// New allocation would not be created.
    Disabled = 2,
}
impl PoolCidrState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PoolCidrState::StateUnspecified => "STATE_UNSPECIFIED",
            PoolCidrState::Available => "AVAILABLE",
            PoolCidrState::Disabled => "DISABLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATE_UNSPECIFIED" => Some(Self::StateUnspecified),
            "AVAILABLE" => Some(Self::Available),
            "DISABLED" => Some(Self::Disabled),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IpVersion {
    /// Default, unspecified IP version.
    Unspecified = 0,
    /// IPv4 address.
    Ipv4 = 1,
    /// IPv6 address.
    Ipv6 = 2,
}
impl IpVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            IpVersion::Unspecified => "IP_VERSION_UNSPECIFIED",
            IpVersion::Ipv4 => "IPV4",
            IpVersion::Ipv6 => "IPV6",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IP_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
            "IPV4" => Some(Self::Ipv4),
            "IPV6" => Some(Self::Ipv6),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Allocation {
    /// Metadata for the Allocation.
    /// `metadata.parent_id` represents IAM Container.
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    /// Specifications for the allocation, detailing its name and IP configuration.
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<AllocationSpec>,
    /// Contains the current status of the allocation, indicating its state and any additional details.
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<AllocationStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationSpec {
    /// Holds the IP specifications for the allocation, including the type of IP (IPv4 or IPv6) and its corresponding configuration.
    #[prost(oneof="allocation_spec::IpSpec", tags="1, 2")]
    pub ip_spec: ::core::option::Option<allocation_spec::IpSpec>,
}
/// Nested message and enum types in `AllocationSpec`.
pub mod allocation_spec {
    /// Holds the IP specifications for the allocation, including the type of IP (IPv4 or IPv6) and its corresponding configuration.
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum IpSpec {
        #[prost(message, tag="1")]
        Ipv4Private(super::IPv4PrivateAllocationSpec),
        #[prost(message, tag="2")]
        Ipv4Public(super::IPv4PublicAllocationSpec),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IPv4PrivateAllocationSpec {
    /// CIDR block for IPv4 Allocation.
    /// May be a single IP address (such as 10.2.3.4),
    /// a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
    /// Random address (/32) from pool would be allocated if field is omitted.
    #[prost(string, tag="1")]
    pub cidr: ::prost::alloc::string::String,
    #[prost(oneof="i_pv4_private_allocation_spec::Pool", tags="2, 3")]
    pub pool: ::core::option::Option<i_pv4_private_allocation_spec::Pool>,
}
/// Nested message and enum types in `IPv4PrivateAllocationSpec`.
pub mod i_pv4_private_allocation_spec {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Pool {
        /// Subnet ID.
        /// Required same subnet to use allocation in subnet-resources (e.g. Network Interface)
        #[prost(string, tag="2")]
        SubnetId(::prost::alloc::string::String),
        /// Pool for the IPv4 private allocation.
        #[prost(string, tag="3")]
        PoolId(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IPv4PublicAllocationSpec {
    /// CIDR block for IPv4 Allocation.
    /// May be a single IP address (such as 10.2.3.4),
    /// a prefix length (such as /32) or a CIDR-formatted string (such as 10.1.2.0/32).
    /// Random address (/32) from pool would be allocated if field is omitted.
    #[prost(string, tag="1")]
    pub cidr: ::prost::alloc::string::String,
    /// Pool for the IPv4 public allocation.
    #[prost(string, tag="2")]
    pub pool_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationStatus {
    /// This field represents the current state of the allocation.
    #[prost(enumeration="allocation_status::State", tag="1")]
    pub state: i32,
    /// Detailed information about the allocation status,
    /// including the allocated CIDR, pool ID, scope type, and IP version.
    #[prost(message, optional, tag="2")]
    pub details: ::core::option::Option<AllocationDetails>,
    /// Information about the assignment associated with the allocation,
    /// such as network interface or load balancer assignment.
    #[prost(message, optional, tag="3")]
    pub assignment: ::core::option::Option<Assignment>,
    /// If false - Lifecycle of allocation depends on resource that using it.
    #[prost(bool, tag="4")]
    pub r#static: bool,
}
/// Nested message and enum types in `AllocationStatus`.
pub mod allocation_status {
    /// Enumeration of possible states of the Allocation.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        /// Default state, unspecified.
        Unspecified = 0,
        /// Allocation is being created.
        Creating = 1,
        /// Allocation is ready for use.
        Allocated = 2,
        /// Allocation is used.
        Assigned = 3,
        /// Allocation is being deleted.
        Deleting = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Allocated => "ALLOCATED",
                State::Assigned => "ASSIGNED",
                State::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ALLOCATED" => Some(Self::Allocated),
                "ASSIGNED" => Some(Self::Assigned),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationDetails {
    #[prost(string, tag="1")]
    pub allocated_cidr: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub pool_id: ::prost::alloc::string::String,
    #[prost(enumeration="IpVersion", tag="4")]
    pub version: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Assignment {
    /// This field specifies the type of assignment associated with the allocation,
    /// which could be a network interface or load balancer assignment.
    #[prost(oneof="assignment::Type", tags="1, 2")]
    pub r#type: ::core::option::Option<assignment::Type>,
}
/// Nested message and enum types in `Assignment`.
pub mod assignment {
    /// This field specifies the type of assignment associated with the allocation,
    /// which could be a network interface or load balancer assignment.
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag="1")]
        NetworkInterface(super::NetworkInterfaceAssignment),
        #[prost(message, tag="2")]
        LoadBalancer(super::LoadBalancerAssignment),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkInterfaceAssignment {
    /// ID of the Compute instance network interface belongs to.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    /// Network interface name
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadBalancerAssignment {
    /// ID of the Load Balancer.
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllocationRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllocationByNameRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAllocationsRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAllocationsResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Allocation>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAllocationRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<AllocationSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAllocationRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<AllocationSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAllocationRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
/// Defines a Network, which serves as a virtual representation of a traditional LAN
/// within a cloud environment.
/// Networks facilitate communication between subnets.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Network {
    /// Metadata for the network resource.
    /// `metadata.parent_id` represents IAM container
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    /// Specification of the network.
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<NetworkSpec>,
    /// Status of the network.
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<NetworkStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkSpec {
    /// Pools for addresses
    #[prost(message, repeated, tag="1")]
    pub pools: ::prost::alloc::vec::Vec<NetworkPool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkPool {
    #[prost(string, tag="1")]
    pub pool_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkStatus {
    /// Current state of the network.
    #[prost(enumeration="network_status::State", tag="1")]
    pub state: i32,
    /// Scope ID of all pools
    #[prost(string, tag="2")]
    pub scope_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `NetworkStatus`.
pub mod network_status {
    /// Enumeration of possible states of the network.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        /// Default state, unspecified.
        Unspecified = 0,
        /// Network is being created.
        Creating = 1,
        /// Network is ready for use.
        Ready = 2,
        /// Network is being deleted.
        Deleting = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Ready => "READY",
                State::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "READY" => Some(Self::Ready),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNetworkRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNetworkByNameRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNetworksRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNetworksResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Network>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPoolRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPoolByNameRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPoolsRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPoolsResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Pool>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Scope {
    /// Metadata associated with the Scope.
    /// `metadata.parent_id` represents the parent IAM container.
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    /// Specification of the Scope.
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<ScopeSpec>,
    /// Status information for the Scope.
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<ScopeStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScopeSpec {
    /// Type of the Scope (Private or Public).
    #[prost(enumeration="scope_spec::Type", tag="1")]
    pub r#type: i32,
}
/// Nested message and enum types in `ScopeSpec`.
pub mod scope_spec {
    /// Type of scope.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        /// Default, unspecified scope type.
        ScopeTypeUnspecified = 0,
        /// Public scope.
        Public = 1,
        /// Private scope.
        Private = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::ScopeTypeUnspecified => "SCOPE_TYPE_UNSPECIFIED",
                Type::Public => "PUBLIC",
                Type::Private => "PRIVATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCOPE_TYPE_UNSPECIFIED" => Some(Self::ScopeTypeUnspecified),
                "PUBLIC" => Some(Self::Public),
                "PRIVATE" => Some(Self::Private),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScopeStatus {
    /// Current state of the Scope.
    #[prost(enumeration="scope_status::State", tag="1")]
    pub state: i32,
}
/// Nested message and enum types in `ScopeStatus`.
pub mod scope_status {
    /// Possible states of the Scope.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        /// Default, unspecified state.
        Unspecified = 0,
        /// Scope is being created.
        Creating = 1,
        /// Scope is ready for use.
        Ready = 2,
        /// Scope is being deleted.
        Deleting = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Ready => "READY",
                State::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "READY" => Some(Self::Ready),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetScopeRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetScopeByNameRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListScopesRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListScopesResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Scope>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Defines a Subnet, a segment of a network used for more granular control and management.
/// Subnet uses pools to organize address space.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Subnet {
    /// Metadata for the subnet resource.
    /// `metadata.parent_id` represents IAM container
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    /// Specification of the subnet.
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<SubnetSpec>,
    /// Status of the subnet.
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<SubnetStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubnetSpec {
    /// Network ID.
    #[prost(string, tag="1")]
    pub network_id: ::prost::alloc::string::String,
    /// Pool for addresses
    #[prost(message, repeated, tag="2")]
    pub pools: ::prost::alloc::vec::Vec<SubnetPool>,
    /// Enable egress NAT gateway
    #[prost(bool, tag="3")]
    pub enable_egress_nat: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubnetPool {
    #[prost(oneof="subnet_pool::Pool", tags="1, 2")]
    pub pool: ::core::option::Option<subnet_pool::Pool>,
}
/// Nested message and enum types in `SubnetPool`.
pub mod subnet_pool {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Pool {
        #[prost(message, tag="1")]
        Spec(super::SubnetPoolSpec),
        #[prost(string, tag="2")]
        PoolId(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubnetPoolSpec {
    #[prost(enumeration="IpVersion", tag="1")]
    pub version: i32,
    #[prost(message, repeated, tag="2")]
    pub cidrs: ::prost::alloc::vec::Vec<SubnetCidr>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubnetCidr {
    /// CIDR block.
    /// May be a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
    #[prost(string, tag="1")]
    pub cidr: ::prost::alloc::string::String,
    /// State of the Cidr.
    #[prost(enumeration="PoolCidrState", tag="2")]
    pub state: i32,
    /// Maximum mask length for allocation from this cidr
    #[prost(int64, tag="3")]
    pub allowed_mask: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubnetStatus {
    /// Current state of the subnet.
    #[prost(enumeration="subnet_status::State", tag="1")]
    pub state: i32,
    /// CIDR blocks.
    #[prost(string, repeated, tag="2")]
    pub ipv4_cidrs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `SubnetStatus`.
pub mod subnet_status {
    /// Enumeration of possible states of the subnet.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        /// Default state, unspecified.
        Unspecified = 0,
        /// Subnet is being created.
        Creating = 1,
        /// Subnet is ready for use.
        Ready = 2,
        /// Subnet is being deleted.
        Deleting = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Ready => "READY",
                State::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "READY" => Some(Self::Ready),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSubnetRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSubnetByNameRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubnetsRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubnetsByNetworkRequest {
    #[prost(string, tag="1")]
    pub network_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubnetsResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Subnet>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
include!("nebius.vpc.v1alpha1.serde.rs");
include!("nebius.vpc.v1alpha1.tonic.rs");
// @@protoc_insertion_point(module)