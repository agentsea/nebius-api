// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Disk {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<DiskSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<DiskStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskSpec {
    #[prost(int64, tag="5")]
    pub block_size_bytes: i64,
    #[prost(enumeration="disk_spec::DiskType", tag="6")]
    pub r#type: i32,
    #[prost(message, optional, tag="7")]
    pub placement_policy: ::core::option::Option<DiskPlacementPolicy>,
    #[prost(oneof="disk_spec::Size", tags="1, 2, 3, 4")]
    pub size: ::core::option::Option<disk_spec::Size>,
    #[prost(oneof="disk_spec::Source", tags="8, 9")]
    pub source: ::core::option::Option<disk_spec::Source>,
}
/// Nested message and enum types in `DiskSpec`.
pub mod disk_spec {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum DiskType {
        Unspecified = 0,
        /// the list of available types will be clarified later, it is not final version
        NetworkSsd = 1,
        NetworkHdd = 2,
        NetworkSsdNonReplicated = 3,
        NetworkSsdIoM3 = 4,
    }
    impl DiskType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DiskType::Unspecified => "UNSPECIFIED",
                DiskType::NetworkSsd => "NETWORK_SSD",
                DiskType::NetworkHdd => "NETWORK_HDD",
                DiskType::NetworkSsdNonReplicated => "NETWORK_SSD_NON_REPLICATED",
                DiskType::NetworkSsdIoM3 => "NETWORK_SSD_IO_M3",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "NETWORK_SSD" => Some(Self::NetworkSsd),
                "NETWORK_HDD" => Some(Self::NetworkHdd),
                "NETWORK_SSD_NON_REPLICATED" => Some(Self::NetworkSsdNonReplicated),
                "NETWORK_SSD_IO_M3" => Some(Self::NetworkSsdIoM3),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Size {
        #[prost(int64, tag="1")]
        SizeBytes(i64),
        #[prost(int64, tag="2")]
        SizeKibibytes(i64),
        #[prost(int64, tag="3")]
        SizeMebibytes(i64),
        #[prost(int64, tag="4")]
        SizeGibibytes(i64),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(string, tag="8")]
        SourceImageId(::prost::alloc::string::String),
        #[prost(string, tag="9")]
        SourceImageFamily(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskPlacementPolicy {
    #[prost(string, tag="1")]
    pub placement_group_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub placement_group_partition: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskStatus {
    #[prost(enumeration="disk_status::State", tag="1")]
    pub state: i32,
    #[prost(string, tag="2")]
    pub state_description: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub read_write_attachment: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="4")]
    pub read_only_attachments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="5")]
    pub source_image_id: ::prost::alloc::string::String,
    #[prost(int64, tag="6")]
    pub size_bytes: i64,
    /// Indicates whether there is an ongoing operation
    #[prost(bool, tag="7")]
    pub reconciling: bool,
}
/// Nested message and enum types in `DiskStatus`.
pub mod disk_status {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        Ready = 2,
        Updating = 3,
        Deleting = 4,
        Error = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "UNSPECIFIED",
                State::Creating => "CREATING",
                State::Ready => "READY",
                State::Updating => "UPDATING",
                State::Deleting => "DELETING",
                State::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "READY" => Some(Self::Ready),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDiskRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDisksRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDiskRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<DiskSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDiskRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<DiskSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDiskRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDisksResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Disk>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Filesystem {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<FilesystemSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<FilesystemStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FilesystemSpec {
    #[prost(int64, tag="5")]
    pub block_size_bytes: i64,
    #[prost(enumeration="filesystem_spec::FilesystemType", tag="6")]
    pub r#type: i32,
    #[prost(oneof="filesystem_spec::Size", tags="1, 2, 3, 4")]
    pub size: ::core::option::Option<filesystem_spec::Size>,
}
/// Nested message and enum types in `FilesystemSpec`.
pub mod filesystem_spec {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum FilesystemType {
        Unspecified = 0,
        /// the list of available types will be clarified later, it is not final version
        NetworkSsd = 1,
        NetworkHdd = 2,
    }
    impl FilesystemType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FilesystemType::Unspecified => "UNSPECIFIED",
                FilesystemType::NetworkSsd => "NETWORK_SSD",
                FilesystemType::NetworkHdd => "NETWORK_HDD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "NETWORK_SSD" => Some(Self::NetworkSsd),
                "NETWORK_HDD" => Some(Self::NetworkHdd),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Size {
        #[prost(int64, tag="1")]
        SizeBytes(i64),
        #[prost(int64, tag="2")]
        SizeKibibytes(i64),
        #[prost(int64, tag="3")]
        SizeMebibytes(i64),
        #[prost(int64, tag="4")]
        SizeGibibytes(i64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilesystemStatus {
    #[prost(enumeration="filesystem_status::State", tag="1")]
    pub state: i32,
    #[prost(string, tag="2")]
    pub state_description: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="3")]
    pub read_write_attachments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="4")]
    pub read_only_attachments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag="5")]
    pub size_bytes: i64,
    /// Indicates whether there is an ongoing operation
    #[prost(bool, tag="6")]
    pub reconciling: bool,
}
/// Nested message and enum types in `FilesystemStatus`.
pub mod filesystem_status {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        Ready = 2,
        Updating = 3,
        Deleting = 4,
        Error = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "UNSPECIFIED",
                State::Creating => "CREATING",
                State::Ready => "READY",
                State::Updating => "UPDATING",
                State::Deleting => "DELETING",
                State::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "READY" => Some(Self::Ready),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilesystemRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFilesystemsRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFilesystemRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<FilesystemSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFilesystemRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<FilesystemSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFilesystemRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFilesystemsResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Filesystem>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuCluster {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<GpuClusterSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<GpuClusterStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuClusterSpec {
    #[prost(string, tag="1")]
    pub infiniband_fabric: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuClusterStatus {
    #[prost(string, repeated, tag="1")]
    pub instances: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Indicates whether there is an ongoing operation
    #[prost(bool, tag="2")]
    pub reconciling: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGpuClusterRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGpuClustersRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateGpuClusterRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<GpuClusterSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateGpuClusterRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<GpuClusterSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteGpuClusterRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGpuClustersResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<GpuCluster>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Image {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<ImageSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<ImageStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageSpec {
    #[prost(string, optional, tag="1")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag="2")]
    pub image_family: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageStatus {
    #[prost(enumeration="image_status::State", tag="1")]
    pub state: i32,
    #[prost(string, tag="2")]
    pub state_description: ::prost::alloc::string::String,
    #[prost(int64, tag="3")]
    pub storage_size_bytes: i64,
    #[prost(int64, tag="4")]
    pub min_disk_size_bytes: i64,
    /// Indicates whether there is an ongoing operation
    #[prost(bool, tag="5")]
    pub reconciling: bool,
}
/// Nested message and enum types in `ImageStatus`.
pub mod image_status {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        Ready = 2,
        Updating = 3,
        Deleting = 4,
        Error = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "UNSPECIFIED",
                State::Creating => "CREATING",
                State::Ready => "READY",
                State::Updating => "UPDATING",
                State::Deleting => "DELETING",
                State::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "READY" => Some(Self::Ready),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetImageRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetImageLatestByFamilyRequest {
    #[prost(string, tag="1")]
    pub image_family: ::prost::alloc::string::String,
    /// default 'project-{region}public-images'
    #[prost(string, tag="2")]
    pub parent_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListImagesRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListImagesResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Image>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Instance {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<InstanceSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<InstanceStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceSpec {
    #[prost(string, tag="1")]
    pub service_account_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub resources: ::core::option::Option<ResourcesSpec>,
    #[prost(message, optional, tag="3")]
    pub gpu_cluster: ::core::option::Option<InstanceGpuClusterSpec>,
    #[prost(message, repeated, tag="4")]
    pub network_interfaces: ::prost::alloc::vec::Vec<super::super::vpc::v1alpha1::NetworkInterfaceSpec>,
    #[prost(message, optional, tag="5")]
    pub boot_disk: ::core::option::Option<AttachedDiskSpec>,
    #[prost(message, repeated, tag="6")]
    pub secondary_disks: ::prost::alloc::vec::Vec<AttachedDiskSpec>,
    #[prost(message, repeated, tag="7")]
    pub filesystems: ::prost::alloc::vec::Vec<AttachedFilesystemSpec>,
    #[prost(string, tag="8")]
    pub cloud_init_user_data: ::prost::alloc::string::String,
    #[prost(bool, tag="13")]
    pub stopped: bool,
    /// Recovery policy defines how the instance will be treated in case of a failure. Common source of failure is a host failure, but it can be any other failure.
    /// Instance undergoing a guest shutdown (poweroff, etc.) will be subject to recovery policy, meaning that it could be restarted and billed accordingly. Stop instance via API or UI to stop it to avoid recovering.
    /// If set to RECOVER, instance will be restarted, if possible. It could be restarted on the same host or on another host.
    /// If set to FAIL, instance will be stopped and not restarted.
    #[prost(enumeration="InstanceRecoveryPolicy", tag="15")]
    pub recovery_policy: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcesSpec {
    #[prost(string, tag="1")]
    pub platform: ::prost::alloc::string::String,
    #[prost(oneof="resources_spec::Size", tags="2")]
    pub size: ::core::option::Option<resources_spec::Size>,
}
/// Nested message and enum types in `ResourcesSpec`.
pub mod resources_spec {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Size {
        #[prost(string, tag="2")]
        Preset(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGpuClusterSpec {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachedDiskSpec {
    #[prost(enumeration="attached_disk_spec::AttachMode", tag="1")]
    pub attach_mode: i32,
    /// Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_name}' as a device path in mount command.
    #[prost(string, tag="3")]
    pub device_name: ::prost::alloc::string::String,
    #[prost(oneof="attached_disk_spec::Type", tags="2")]
    pub r#type: ::core::option::Option<attached_disk_spec::Type>,
}
/// Nested message and enum types in `AttachedDiskSpec`.
pub mod attached_disk_spec {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum AttachMode {
        Unspecified = 0,
        ReadOnly = 1,
        ReadWrite = 2,
    }
    impl AttachMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AttachMode::Unspecified => "UNSPECIFIED",
                AttachMode::ReadOnly => "READ_ONLY",
                AttachMode::ReadWrite => "READ_WRITE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "READ_ONLY" => Some(Self::ReadOnly),
                "READ_WRITE" => Some(Self::ReadWrite),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag="2")]
        ExistingDisk(super::ExistingDisk),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExistingDisk {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExistingFilesystem {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachedFilesystemSpec {
    #[prost(enumeration="attached_filesystem_spec::AttachMode", tag="1")]
    pub attach_mode: i32,
    /// Specifies the user-defined identifier, allowing to use it as a device in mount command.
    #[prost(string, tag="2")]
    pub device_name: ::prost::alloc::string::String,
    #[prost(oneof="attached_filesystem_spec::Type", tags="3")]
    pub r#type: ::core::option::Option<attached_filesystem_spec::Type>,
}
/// Nested message and enum types in `AttachedFilesystemSpec`.
pub mod attached_filesystem_spec {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum AttachMode {
        Unspecified = 0,
        ReadOnly = 1,
        ReadWrite = 2,
    }
    impl AttachMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AttachMode::Unspecified => "UNSPECIFIED",
                AttachMode::ReadOnly => "READ_ONLY",
                AttachMode::ReadWrite => "READ_WRITE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "READ_ONLY" => Some(Self::ReadOnly),
                "READ_WRITE" => Some(Self::ReadWrite),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag="3")]
        ExistingFilesystem(super::ExistingFilesystem),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceStatus {
    #[prost(enumeration="instance_status::InstanceState", tag="1")]
    pub state: i32,
    #[prost(message, repeated, tag="2")]
    pub network_interfaces: ::prost::alloc::vec::Vec<super::super::vpc::v1alpha1::NetworkInterfaceStatus>,
    /// Indicates whether there is an ongoing operation
    #[prost(bool, tag="5")]
    pub reconciling: bool,
}
/// Nested message and enum types in `InstanceStatus`.
pub mod instance_status {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum InstanceState {
        Unspecified = 0,
        Creating = 1,
        Updating = 2,
        Starting = 3,
        Running = 4,
        Stopping = 5,
        Stopped = 6,
        Deleting = 7,
        Error = 8,
    }
    impl InstanceState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InstanceState::Unspecified => "UNSPECIFIED",
                InstanceState::Creating => "CREATING",
                InstanceState::Updating => "UPDATING",
                InstanceState::Starting => "STARTING",
                InstanceState::Running => "RUNNING",
                InstanceState::Stopping => "STOPPING",
                InstanceState::Stopped => "STOPPED",
                InstanceState::Deleting => "DELETING",
                InstanceState::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "UPDATING" => Some(Self::Updating),
                "STARTING" => Some(Self::Starting),
                "RUNNING" => Some(Self::Running),
                "STOPPING" => Some(Self::Stopping),
                "STOPPED" => Some(Self::Stopped),
                "DELETING" => Some(Self::Deleting),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InstanceRecoveryPolicy {
    Recover = 0,
    Fail = 1,
}
impl InstanceRecoveryPolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            InstanceRecoveryPolicy::Recover => "RECOVER",
            InstanceRecoveryPolicy::Fail => "FAIL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RECOVER" => Some(Self::Recover),
            "FAIL" => Some(Self::Fail),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInstanceRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstancesRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInstanceRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<InstanceSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInstanceRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<InstanceSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInstanceRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstancesResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Instance>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartInstanceRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopInstanceRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
include!("nebius.compute.v1alpha1.serde.rs");
include!("nebius.compute.v1alpha1.tonic.rs");
// @@protoc_insertion_point(module)