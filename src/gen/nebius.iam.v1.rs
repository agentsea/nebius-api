// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Account {
    #[prost(oneof="account::Type", tags="1, 2, 3")]
    pub r#type: ::core::option::Option<account::Type>,
}
/// Nested message and enum types in `Account`.
pub mod account {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UserAccount {
        #[prost(string, tag="1")]
        pub id: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ServiceAccount {
        #[prost(string, tag="1")]
        pub id: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AnonymousAccount {
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag="1")]
        UserAccount(UserAccount),
        #[prost(message, tag="2")]
        ServiceAccount(ServiceAccount),
        #[prost(message, tag="3")]
        AnonymousAccount(AnonymousAccount),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessKey {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<AccessKeySpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<AccessKeyStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessKeySpec {
    #[prost(message, optional, tag="1")]
    pub account: ::core::option::Option<Account>,
    #[prost(message, optional, tag="2")]
    pub expires_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, tag="3")]
    pub description: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessKeyStatus {
    #[prost(enumeration="access_key_status::State", tag="1")]
    pub state: i32,
    #[prost(string, tag="2")]
    pub fingerprint: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub algorithm: ::prost::alloc::string::String,
    #[prost(int32, tag="4")]
    pub key_size: i32,
    #[prost(string, tag="5")]
    pub aws_access_key_id: ::prost::alloc::string::String,
    #[prost(string, tag="6")]
    pub secret: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AccessKeyStatus`.
pub mod access_key_status {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Inactive = 2,
        Expired = 3,
        Deleting = 4,
        Deleted = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::Inactive => "INACTIVE",
                State::Expired => "EXPIRED",
                State::Deleting => "DELETING",
                State::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                "EXPIRED" => Some(Self::Expired),
                "DELETING" => Some(Self::Deleting),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAccessKeyRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<AccessKeySpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyIdentity {
    #[prost(oneof="key_identity::Identity", tags="1, 2")]
    pub identity: ::core::option::Option<key_identity::Identity>,
}
/// Nested message and enum types in `KeyIdentity`.
pub mod key_identity {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Identity {
        #[prost(string, tag="1")]
        Id(::prost::alloc::string::String),
        #[prost(string, tag="2")]
        AwsAccessKeyId(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccessKeySecretOnceRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccessKeyByIdRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccessKeyByAwsIdRequest {
    #[prost(string, tag="1")]
    pub aws_access_key_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccessKeysRequest {
    /// Represents the container ID.
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// Specifies the maximum number of items to return in the response.
    /// Default value: 10
    #[prost(int64, optional, tag="2")]
    pub page_size: ::core::option::Option<i64>,
    /// Token for pagination, allowing the retrieval of the next set of results.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    /// A filter to narrow down the results based on specific criteria.
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccessKeysByAccountRequest {
    /// Represents the parent account ID.
    #[prost(message, optional, tag="1")]
    pub account: ::core::option::Option<Account>,
    /// Specifies the maximum number of items to return in the response.
    /// Default value: 10
    #[prost(int64, tag="2")]
    pub page_size: i64,
    /// Token for pagination, allowing the retrieval of the next set of results.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    /// A filter to narrow down the results based on specific criteria.
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAccessKeyRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<AccessKeySpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivateAccessKeyRequest {
    #[prost(message, optional, tag="1")]
    pub id: ::core::option::Option<KeyIdentity>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeactivateAccessKeyRequest {
    #[prost(message, optional, tag="1")]
    pub id: ::core::option::Option<KeyIdentity>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAccessKeyRequest {
    #[prost(message, optional, tag="1")]
    pub id: ::core::option::Option<KeyIdentity>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccessKeySecretOnceResponse {
    #[prost(string, tag="1")]
    pub secret: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccessKeysResponse {
    /// List of access keys returned in the response. The field should be named as `items` for consistency.
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<AccessKey>,
    /// Token for pagination, indicating the next set of results can be retrieved using this token.
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessPermit {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<AccessPermitSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<AccessPermitStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessPermitSpec {
    /// Resource for granting access permit.
    #[prost(string, tag="1")]
    pub resource_id: ::prost::alloc::string::String,
    /// Role for granting access permit.
    #[prost(string, tag="2")]
    pub role: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccessPermitStatus {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAccessPermitRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<AccessPermitSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccessPermitRequest {
    /// Represents the container ID.
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// Specifies the maximum number of items to return in the response.
    #[prost(int64, tag="2")]
    pub page_size: i64,
    /// Token for pagination, allowing the retrieval of the next set of results.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    /// A filter to narrow down the results based on specific criteria.
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAccessPermitRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccessPermitRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccessPermitResponse {
    /// List of access bindings returned in the response. The field should be named as `items` for consistency.
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<AccessPermit>,
    /// Token for pagination, indicating the next set of results can be retrieved using this token.
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthPublicKey {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<AuthPublicKeySpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<AuthPublicKeyStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthPublicKeySpec {
    #[prost(message, optional, tag="1")]
    pub account: ::core::option::Option<Account>,
    #[prost(message, optional, tag="2")]
    pub expires_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, tag="3")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub data: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthPublicKeyStatus {
    #[prost(enumeration="auth_public_key_status::State", tag="1")]
    pub state: i32,
    #[prost(string, tag="2")]
    pub fingerprint: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub algorithm: ::prost::alloc::string::String,
    #[prost(int32, tag="4")]
    pub key_size: i32,
}
/// Nested message and enum types in `AuthPublicKeyStatus`.
pub mod auth_public_key_status {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Inactive = 2,
        Expired = 3,
        Deleting = 4,
        Deleted = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::Inactive => "INACTIVE",
                State::Expired => "EXPIRED",
                State::Deleting => "DELETING",
                State::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                "EXPIRED" => Some(Self::Expired),
                "DELETING" => Some(Self::Deleting),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAuthPublicKeyRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<AuthPublicKeySpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAuthPublicKeyRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAuthPublicKeyRequest {
    /// Represents the container ID.
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// Specifies the maximum number of items to return in the response.
    /// Default value: 10
    #[prost(int64, optional, tag="2")]
    pub page_size: ::core::option::Option<i64>,
    /// Token for pagination, allowing the retrieval of the next set of results.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    /// A filter to narrow down the results based on specific criteria.
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAuthPublicKeyByAccountRequest {
    /// Represents the parent account ID.
    #[prost(message, optional, tag="1")]
    pub account: ::core::option::Option<Account>,
    /// Specifies the maximum number of items to return in the response.
    /// Default value: 10
    #[prost(int64, tag="2")]
    pub page_size: i64,
    /// Token for pagination, allowing the retrieval of the next set of results.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    /// A filter to narrow down the results based on specific criteria.
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAuthPublicKeyRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<AuthPublicKeySpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivateAuthPublicKeyRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeactivateAuthPublicKeyRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAuthPublicKeyRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAuthPublicKeyResponse {
    /// List of auth public keys returned in the response. The field should be named as `items` for consistency.
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<AuthPublicKey>,
    /// Token for pagination, indicating the next set of results can be retrieved using this token.
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
    Unspecified = 0,
    Active = 1,
    SchedulingForDeletion = 2,
    ScheduledForDeletion = 3,
    SchedulingForDeletionByParent = 4,
    ScheduledForDeletionByParent = 5,
    Undeleting = 6,
    Purging = 7,
    Purged = 8,
    /// DRAFT = 1000;
    Creating = 1001,
}
impl State {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            State::Unspecified => "STATE_UNSPECIFIED",
            State::Active => "ACTIVE",
            State::SchedulingForDeletion => "SCHEDULING_FOR_DELETION",
            State::ScheduledForDeletion => "SCHEDULED_FOR_DELETION",
            State::SchedulingForDeletionByParent => "SCHEDULING_FOR_DELETION_BY_PARENT",
            State::ScheduledForDeletionByParent => "SCHEDULED_FOR_DELETION_BY_PARENT",
            State::Undeleting => "UNDELETING",
            State::Purging => "PURGING",
            State::Purged => "PURGED",
            State::Creating => "CREATING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "ACTIVE" => Some(Self::Active),
            "SCHEDULING_FOR_DELETION" => Some(Self::SchedulingForDeletion),
            "SCHEDULED_FOR_DELETION" => Some(Self::ScheduledForDeletion),
            "SCHEDULING_FOR_DELETION_BY_PARENT" => Some(Self::SchedulingForDeletionByParent),
            "SCHEDULED_FOR_DELETION_BY_PARENT" => Some(Self::ScheduledForDeletionByParent),
            "UNDELETING" => Some(Self::Undeleting),
            "PURGING" => Some(Self::Purging),
            "PURGED" => Some(Self::Purged),
            "CREATING" => Some(Self::Creating),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SuspensionState {
    Unspecified = 0,
    None = 1,
    Suspending = 2,
    Suspended = 3,
    Resuming = 4,
}
impl SuspensionState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SuspensionState::Unspecified => "SUSPENSION_STATE_UNSPECIFIED",
            SuspensionState::None => "NONE",
            SuspensionState::Suspending => "SUSPENDING",
            SuspensionState::Suspended => "SUSPENDED",
            SuspensionState::Resuming => "RESUMING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SUSPENSION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "NONE" => Some(Self::None),
            "SUSPENDING" => Some(Self::Suspending),
            "SUSPENDED" => Some(Self::Suspended),
            "RESUMING" => Some(Self::Resuming),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Container {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<ContainerSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<ContainerStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContainerSpec {
    #[prost(string, tag="1")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContainerStatus {
    #[prost(enumeration="SuspensionState", tag="2")]
    pub suspension_state: i32,
    #[prost(enumeration="State", tag="3")]
    pub container_state: i32,
    #[prost(string, tag="4")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FederatedCredentials {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<FederatedCredentialsSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<FederatedCredentialsStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FederatedCredentialsSpec {
    #[prost(string, tag="101")]
    pub federated_subject_id: ::prost::alloc::string::String,
    /// IAM subject, in which federated subject will be impersonated to.
    /// E.g. for workload identities it will be IAM service account.
    #[prost(string, tag="111")]
    pub subject_id: ::prost::alloc::string::String,
    /// provider of federated credentials used for federated subject authentication
    #[prost(oneof="federated_credentials_spec::CredentialsProvider", tags="1")]
    pub credentials_provider: ::core::option::Option<federated_credentials_spec::CredentialsProvider>,
}
/// Nested message and enum types in `FederatedCredentialsSpec`.
pub mod federated_credentials_spec {
    /// provider of federated credentials used for federated subject authentication
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CredentialsProvider {
        #[prost(message, tag="1")]
        OidcProvider(super::OidcCredentialsProvider),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OidcCredentialsProvider {
    /// *
    /// It's not required provider OIDC issuer should be real OIDC provider, but should expose OIDC configuration
    /// with "/.well-known/openid-configuration" endpoint. Configuration should contains the "jwks_uri" endpoint
    /// where the JSON Web Key Set (JWKS) can be found; this set contains public keys used to verify
    /// JSON Web Tokens (JWTs) issued by an identity provider.
    #[prost(string, tag="1")]
    pub issuer_url: ::prost::alloc::string::String,
    /// *
    /// Literally json, which represents JWKS with public keys for JWT verification
    #[prost(string, tag="2")]
    pub jwk_set_json: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FederatedCredentialsStatus {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFederatedCredentialsRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetByNameFederatedCredentialsRequest {
    /// Container (project), which contains desired credentials.
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// Federated credentials name.
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFederatedCredentialsRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<FederatedCredentialsSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFederatedCredentialsRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<FederatedCredentialsSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFederatedCredentialsRequest {
    /// Represents the parent NID
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// Specifies the maximum number of items to return in the response. Default is 10
    #[prost(int64, tag="2")]
    pub page_size: i64,
    /// Token for pagination, allowing the retrieval of the next set of results.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    /// A filter to narrow down the results based on specific criteria.
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFederatedCredentialsResponse {
    /// List of user accounts returned in the response. The field should be named as `items` for consistency.
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<FederatedCredentials>,
    /// Token for pagination, indicating the next set of results can be retrieved using this token.
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFederatedCredentialsRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Federation {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<FederationSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<FederationStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FederationSpec {
    #[prost(bool, tag="1")]
    pub user_account_auto_creation: bool,
    #[prost(bool, tag="4")]
    pub active: bool,
    #[prost(oneof="federation_spec::Settings", tags="10")]
    pub settings: ::core::option::Option<federation_spec::Settings>,
}
/// Nested message and enum types in `FederationSpec`.
pub mod federation_spec {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Settings {
        #[prost(message, tag="10")]
        SamlSettings(super::SamlSettings),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SamlSettings {
    #[prost(string, tag="1")]
    pub idp_issuer: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub sso_url: ::prost::alloc::string::String,
    /// if "true", the identity provider MUST authenticate the presenter directly rather than rely on a previous security context.
    #[prost(bool, tag="3")]
    pub force_authn: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FederationStatus {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FederationCertificate {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<FederationCertificateSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<FederationCertificateStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FederationCertificateSpec {
    #[prost(string, tag="1")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub data: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FederationCertificateStatus {
    #[prost(enumeration="federation_certificate_status::State", tag="1")]
    pub state: i32,
    #[prost(string, tag="3")]
    pub algorithm: ::prost::alloc::string::String,
    #[prost(int64, tag="4")]
    pub key_size: i64,
    #[prost(message, optional, tag="5")]
    pub not_before: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(message, optional, tag="6")]
    pub not_after: ::core::option::Option<::pbjson_types::Timestamp>,
}
/// Nested message and enum types in `FederationCertificateStatus`.
pub mod federation_certificate_status {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Expired = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::Expired => "EXPIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "EXPIRED" => Some(Self::Expired),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFederationCertificateRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<FederationCertificateSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFederationCertificateRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFederationCertificateByFederationRequest {
    /// Represents the parent federation ID. Corresponds to the parent_id value.
    #[prost(string, tag="1")]
    pub federation_id: ::prost::alloc::string::String,
    /// Specifies the maximum number of items to return in the response.
    /// Default value: 10
    #[prost(int64, tag="2")]
    pub page_size: i64,
    /// Token for pagination, allowing the retrieval of the next set of results.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFederationCertificateRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<FederationCertificateSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFederationCertificateRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFederationCertificateResponse {
    /// List of public keys returned in the response. The field should be named as `items` for consistency.
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<FederationCertificate>,
    /// Token for pagination, indicating the next set of results can be retrieved using this token.
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFederationRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<FederationSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFederationRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFederationsRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// Default value: 10
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFederationsResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Federation>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFederationRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<FederationSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<FederationStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFederationRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Group {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<GroupSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<GroupStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GroupSpec {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GroupStatus {
    #[prost(enumeration="group_status::State", tag="1")]
    pub state: i32,
    #[prost(int32, tag="2")]
    pub members_count: i32,
    #[prost(int32, tag="3")]
    pub service_accounts_count: i32,
    #[prost(int32, tag="4")]
    pub tenant_user_accounts_count: i32,
}
/// Nested message and enum types in `GroupStatus`.
pub mod group_status {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "UNSPECIFIED",
                State::Active => "ACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceAccount {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<ServiceAccountSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<ServiceAccountStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceAccountSpec {
    #[prost(string, tag="1")]
    pub description: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServiceAccountStatus {
    #[prost(bool, tag="1")]
    pub active: bool,
}
/// see also nebius/iam/v1/tenant_user_account.proto/UserAttributes
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceAccountAttributes {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub description: ::prost::alloc::string::String,
}
// this proto describes projections of global user accounts to specific tenants
// every global user account gets a specific id like 'tenantuseraccount-someuniquesuffix'
// inside those tenants where access to their resources is granted to them
//
// global user accounts are described separately in user_account*.proto

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TenantUserAccount {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<TenantUserAccountSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<TenantUserAccountStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TenantUserAccountWithAttributes {
    #[prost(message, optional, tag="1")]
    pub tenant_user_account: ::core::option::Option<TenantUserAccount>,
    #[prost(oneof="tenant_user_account_with_attributes::AttributesOptional", tags="2, 3")]
    pub attributes_optional: ::core::option::Option<tenant_user_account_with_attributes::AttributesOptional>,
}
/// Nested message and enum types in `TenantUserAccountWithAttributes`.
pub mod tenant_user_account_with_attributes {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AttributesOptional {
        #[prost(message, tag="2")]
        Attributes(super::UserAttributes),
        /// in a case of issues of getting attributes from pds service, we can still return some data from cpl
        #[prost(message, tag="3")]
        Error(super::Error),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserAttributes {
    #[prost(string, optional, tag="20")]
    pub sub: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub given_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub family_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub preferred_username: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="5")]
    pub picture: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="6")]
    pub email: ::core::option::Option<::prost::alloc::string::String>,
    #[deprecated]
    #[prost(bool, optional, tag="7")]
    pub email_verified: ::core::option::Option<bool>,
    #[deprecated]
    #[prost(string, optional, tag="8")]
    pub zoneinfo: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="9")]
    pub locale: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="10")]
    pub phone_number: ::core::option::Option<::prost::alloc::string::String>,
    #[deprecated]
    #[prost(bool, optional, tag="11")]
    pub phone_number_verified: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Error {
    #[prost(string, tag="1")]
    pub message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TenantUserAccountSpec {
    #[prost(message, optional, tag="1")]
    pub visible_attributes: ::core::option::Option<tenant_user_account_spec::VisibleAttributes>,
}
/// Nested message and enum types in `TenantUserAccountSpec`.
pub mod tenant_user_account_spec {
    /// when a global user account is projected to a specific tenant
    /// they can give consent for that tenant's owner to view specific personal data
    /// by listing explicitly visible PDS attributes
    /// complete list of PDS attributes is described in ../../pds/inner/v1alpha1/iam_identifier.proto
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VisibleAttributes {
        #[prost(string, repeated, tag="1")]
        pub attribute: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TenantUserAccountStatus {
    #[prost(enumeration="tenant_user_account_status::State", tag="1")]
    pub state: i32,
    /// if a tenant user account is created during invitation it gets a reference to the invitation resource
    /// once invitation is accepted it looses this reference (and internally gets a reference to their global federated user account)
    #[prost(string, tag="2")]
    pub invitation_id: ::prost::alloc::string::String,
    /// currently can only accept the values: custom, unknown, google, github.
    #[prost(string, tag="3")]
    pub federation_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `TenantUserAccountStatus`.
pub mod tenant_user_account_status {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Inactive = 2,
        Blocked = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::Inactive => "INACTIVE",
                State::Blocked => "BLOCKED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                "BLOCKED" => Some(Self::Blocked),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupMembership {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<GroupMembershipSpec>,
    /// Dummy field for compliance with terraform resource generator.
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<GroupMembershipStatus>,
    #[prost(message, optional, tag="4")]
    pub revoke_at: ::core::option::Option<::pbjson_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupMembershipSpec {
    /// Member of the group. Can be tenant user account id or service account id.
    #[prost(string, tag="1")]
    pub member_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GroupMembershipStatus {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GroupMemberKind {
    #[prost(enumeration="group_member_kind::Kind", tag="1")]
    pub kind: i32,
}
/// Nested message and enum types in `GroupMemberKind`.
pub mod group_member_kind {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Kind {
        Unspecified = 0,
        OrdinaryTenantUserAccount = 1,
        InvitedTenantUserAccount = 2,
        ServiceAccount = 3,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Kind::Unspecified => "KIND_UNSPECIFIED",
                Kind::OrdinaryTenantUserAccount => "ORDINARY_TENANT_USER_ACCOUNT",
                Kind::InvitedTenantUserAccount => "INVITED_TENANT_USER_ACCOUNT",
                Kind::ServiceAccount => "SERVICE_ACCOUNT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "KIND_UNSPECIFIED" => Some(Self::Unspecified),
                "ORDINARY_TENANT_USER_ACCOUNT" => Some(Self::OrdinaryTenantUserAccount),
                "INVITED_TENANT_USER_ACCOUNT" => Some(Self::InvitedTenantUserAccount),
                "SERVICE_ACCOUNT" => Some(Self::ServiceAccount),
                _ => None,
            }
        }
    }
}
/// see also nebius/iam/v1/tenant_user_account.proto/TenantUserAccountWithAttributes
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupMembershipWithAttributes {
    #[prost(message, optional, tag="1")]
    pub group_membership: ::core::option::Option<GroupMembership>,
    #[prost(message, optional, tag="11")]
    pub group_member_kind: ::core::option::Option<GroupMemberKind>,
    #[prost(oneof="group_membership_with_attributes::AttributesOptional", tags="2, 3, 99")]
    pub attributes_optional: ::core::option::Option<group_membership_with_attributes::AttributesOptional>,
}
/// Nested message and enum types in `GroupMembershipWithAttributes`.
pub mod group_membership_with_attributes {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AttributesOptional {
        /// filled with known data for members corresponding to tenant user accounts and provisional tenant user accounts (invitees)
        /// left unset for service accounts
        #[prost(message, tag="2")]
        UserAttributes(super::UserAttributes),
        /// filled with known data for members corresponding to service accounts
        /// left unset for any kind of tenant user accounts
        #[prost(message, tag="3")]
        ServiceAccountAttributes(super::ServiceAccountAttributes),
        /// in a case of issues of getting attributes from pds service, we can still return some data from cpl
        #[prost(message, tag="99")]
        Error(super::Error),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateGroupMembershipRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<GroupMembershipSpec>,
    #[prost(int64, tag="4")]
    pub revoke_after_hours: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteGroupMembershipRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGroupMembershipRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGroupMembershipsRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// Default value: 10
    #[prost(int64, optional, tag="2")]
    pub page_size: ::core::option::Option<i64>,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMemberOfRequest {
    /// Requested subject id. Can be tenant user account id or service account id.
    #[prost(string, tag="1")]
    pub subject_id: ::prost::alloc::string::String,
    /// Default value: 10
    #[prost(int64, optional, tag="2")]
    pub page_size: ::core::option::Option<i64>,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGroupMembershipsResponse {
    /// Members of the group. Can be tenant user account ids or service account ids.
    #[prost(message, repeated, tag="1")]
    pub memberships: ::prost::alloc::vec::Vec<GroupMembership>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGroupMembershipsWithAttributesResponse {
    /// Members of the group with their attributes if supported by member type.
    /// Can be tenant user accounts (regular or provisional/invited) or service accounts.
    /// Regular tenant user accounts may have a full set of attributes, provisional may have contacts only,
    /// service accounts
    #[prost(message, repeated, tag="1")]
    pub memberships: ::prost::alloc::vec::Vec<GroupMembershipWithAttributes>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMemberOfResponse {
    /// Groups that requested entity is a member of
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Group>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateGroupRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<GroupSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGroupRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGroupByNameRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGroupsRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// Default value: 10
    #[prost(int64, optional, tag="2")]
    pub page_size: ::core::option::Option<i64>,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGroupsResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Group>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteGroupRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateGroupRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<GroupSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Invitation {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<InvitationSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<InvitationStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvitationSpec {
    #[prost(string, tag="1")]
    pub description: ::prost::alloc::string::String,
    #[prost(oneof="invitation_spec::Contact", tags="11")]
    pub contact: ::core::option::Option<invitation_spec::Contact>,
}
/// Nested message and enum types in `InvitationSpec`.
pub mod invitation_spec {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Contact {
        #[prost(string, tag="11")]
        Email(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvitationStatus {
    #[prost(string, tag="1")]
    pub tenant_user_account_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub expires_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(enumeration="invitation_status::State", tag="3")]
    pub state: i32,
}
/// Nested message and enum types in `InvitationStatus`.
pub mod invitation_status {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        /// contacts data is not stored in pds yet. probably will GC it later
        Creating = 4,
        /// notification is not sent yet
        Created = 5,
        /// notification is sent, we are waiting for the user to approve the notification
        Pending = 1,
        /// notification is expired, accept is no longer possible
        Expired = 2,
        /// notification is accepted
        Accepted = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "UNSPECIFIED",
                State::Creating => "CREATING",
                State::Created => "CREATED",
                State::Pending => "PENDING",
                State::Expired => "EXPIRED",
                State::Accepted => "ACCEPTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "CREATED" => Some(Self::Created),
                "PENDING" => Some(Self::Pending),
                "EXPIRED" => Some(Self::Expired),
                "ACCEPTED" => Some(Self::Accepted),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInvitationRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<InvitationSpec>,
    /// if set, no sending is attempted (it's supposed that later a Resend method is called)
    #[prost(bool, tag="3")]
    pub no_send: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInvitationRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInvitationsRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInvitationsResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Invitation>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInvitationRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInvitationRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<InvitationSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResendInvitationRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserAccountExternalId {
    #[prost(string, tag="1")]
    pub federation_user_account_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub federation_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetProfileRequest {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProfileResponse {
    #[prost(oneof="get_profile_response::Profile", tags="1, 2, 3")]
    pub profile: ::core::option::Option<get_profile_response::Profile>,
}
/// Nested message and enum types in `GetProfileResponse`.
pub mod get_profile_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Profile {
        #[prost(message, tag="1")]
        UserProfile(super::UserProfile),
        #[prost(message, tag="2")]
        ServiceAccountProfile(super::ServiceAccountProfile),
        #[prost(message, tag="3")]
        AnonymousProfile(super::AnonymousAccount),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserProfile {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub federation_info: ::core::option::Option<UserAccountExternalId>,
    #[prost(message, repeated, tag="5")]
    pub tenants: ::prost::alloc::vec::Vec<UserTenantInfo>,
    #[prost(oneof="user_profile::AttributesOptional", tags="3, 4")]
    pub attributes_optional: ::core::option::Option<user_profile::AttributesOptional>,
}
/// Nested message and enum types in `UserProfile`.
pub mod user_profile {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AttributesOptional {
        #[prost(message, tag="3")]
        Attributes(super::UserAttributes),
        #[prost(message, tag="4")]
        RetrievingError(super::Error),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserTenantInfo {
    #[prost(string, tag="1")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub tenant_user_account_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceAccountProfile {
    #[prost(message, optional, tag="1")]
    pub info: ::core::option::Option<ServiceAccount>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnonymousAccount {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProjectRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<ContainerSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProjectRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProjectByNameRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProjectsRequest {
    /// Represents the container ID.
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// Specifies the maximum number of items to return in the response.
    /// Default value: 10
    #[prost(int64, optional, tag="2")]
    pub page_size: ::core::option::Option<i64>,
    /// Token for pagination, allowing the retrieval of the next set of results.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    /// A filter to narrow down the results based on specific criteria.
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateProjectRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<ContainerSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProjectsResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Container>,
    /// Token for pagination, indicating the next set of results can be retrieved using this token.
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateServiceAccountRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<ServiceAccountSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServiceAccountRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServiceAccountByNameRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListServiceAccountRequest {
    /// Represents the container ID.
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// Specifies the maximum number of items to return in the response.
    /// Default value: 10
    #[prost(int64, optional, tag="2")]
    pub page_size: ::core::option::Option<i64>,
    /// Token for pagination, allowing the retrieval of the next set of results.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    /// A filter to narrow down the results based on specific criteria.
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateServiceAccountRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<ServiceAccountSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteServiceAccountRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListServiceAccountResponse {
    /// List of service accounts returned in the response. The field should be named as `items` for consistency.
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<ServiceAccount>,
    /// Token for pagination, indicating the next set of results can be retrieved using this token.
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RevokeSessionRequest {
    #[prost(oneof="revoke_session_request::Revoke", tags="3, 6, 7")]
    pub revoke: ::core::option::Option<revoke_session_request::Revoke>,
}
/// Nested message and enum types in `RevokeSessionRequest`.
pub mod revoke_session_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Revoke {
        /// revoke all for specific service account - to revoke logout from all sessions for user
        #[prost(string, tag="3")]
        ServiceAccountId(::prost::alloc::string::String),
        /// revoke all active session of current user
        #[prost(bool, tag="6")]
        AllMyActive(bool),
        /// revoke all for specific tenant user - to revoke logout from all sessions for user
        #[prost(string, tag="7")]
        TenantUserAccountId(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RevokeSessionResponse {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StaticKey {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<StaticKeySpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<StaticKeyStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StaticKeySpec {
    /// account of the static key. only service accounts are supported for now
    #[prost(message, optional, tag="1")]
    pub account: ::core::option::Option<Account>,
    /// service static key is to be used for
    #[prost(enumeration="static_key_spec::ClientService", tag="2")]
    pub service: i32,
    /// when will the static key expire
    #[prost(message, optional, tag="3")]
    pub expires_at: ::core::option::Option<::pbjson_types::Timestamp>,
}
/// Nested message and enum types in `StaticKeySpec`.
pub mod static_key_spec {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ClientService {
        Unspecified = 0,
        Observability = 1,
        ContainerRegistry = 2,
    }
    impl ClientService {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ClientService::Unspecified => "CLIENT_SERVICE_UNSPECIFIED",
                ClientService::Observability => "OBSERVABILITY",
                ClientService::ContainerRegistry => "CONTAINER_REGISTRY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CLIENT_SERVICE_UNSPECIFIED" => Some(Self::Unspecified),
                "OBSERVABILITY" => Some(Self::Observability),
                "CONTAINER_REGISTRY" => Some(Self::ContainerRegistry),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StaticKeyStatus {
    #[prost(bool, tag="1")]
    pub active: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStaticKeyRequest {
    /// id of the static key
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStaticKeyByNameRequest {
    /// id of the parent container (service account)
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// name of the static key
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteStaticKeyRequest {
    /// id of the static key to delete
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListStaticKeysRequest {
    /// Represents the container ID.
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// Specifies the maximum number of items to return in the response.
    /// Default value: 10
    #[prost(int64, tag="2")]
    pub page_size: i64,
    /// Token for pagination, allowing the retrieval of the next set of results.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    /// A filter to narrow down the results based on specific criteria.
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListStaticKeysResponse {
    /// List of static keys returned in the response. The field should be named as `items` for consistency.
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<StaticKey>,
    /// Token for pagination, indicating the next set of results can be retrieved using this token.
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssueStaticKeyRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<StaticKeySpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssueStaticKeyResponse {
    #[prost(string, tag="1")]
    pub token: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub operation: ::core::option::Option<super::super::common::v1::Operation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindStaticKeyRequest {
    /// the method accepts a static key token with and without signature as an input
    #[prost(string, tag="1")]
    pub token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindStaticKeyResponse {
    #[prost(message, optional, tag="1")]
    pub static_key: ::core::option::Option<StaticKey>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RevokeStaticKeyRequest {
    /// the method accepts a static key token with and without signature as an input
    #[prost(string, tag="1")]
    pub token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTenantRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTenantsRequest {
    /// Specifies the maximum number of items to return in the response.
    /// Default value: 10
    #[prost(int64, optional, tag="1")]
    pub page_size: ::core::option::Option<i64>,
    /// Token for pagination, allowing the retrieval of the next set of results.
    #[prost(string, tag="2")]
    pub page_token: ::prost::alloc::string::String,
    /// A filter to narrow down the results based on specific criteria.
    #[prost(string, tag="3")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTenantsResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Container>,
    /// Token for pagination, indicating the next set of results can be retrieved using this token.
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTenantUserAccountRequest {
    /// tenant user account id like 'tenantuseraccount-{region}someuniquesuffix'
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTenantUserAccountsRequest {
    /// Represents the tenant ID like 'tenant-someuniqueprefix'
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// Specifies the maximum number of items to return in the response.
    /// Default value: 10
    #[prost(int64, optional, tag="2")]
    pub page_size: ::core::option::Option<i64>,
    /// Token for pagination, allowing the retrieval of the next set of results.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTenantUserAccountsResponse {
    /// List of service accounts returned in the response. The field should be named as `items` for consistency.
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<TenantUserAccount>,
    /// Token for pagination, indicating the next set of results can be retrieved using this token.
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockTenantUserAccountRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnblockTenantUserAccountRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTenantUserAccountWithAttributesRequest {
    /// tenant user account id like 'tenantuseraccount-{region}someuniquesuffix'
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTenantUserAccountsWithAttributesRequest {
    /// Represents the tenant ID like 'tenant-{region}someuniquesuffix'
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// Specifies the maximum number of items to return in the response.
    /// Default value: 10
    #[prost(int64, optional, tag="2")]
    pub page_size: ::core::option::Option<i64>,
    /// Token for pagination, allowing the retrieval of the next set of results.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTenantUserAccountsWithAttributesResponse {
    /// List of user accounts returned in the response. The field should be named as `items` for consistency.
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<TenantUserAccountWithAttributes>,
    /// Token for pagination, indicating the next set of results can be retrieved using this token.
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// <https://www.rfc-editor.org/rfc/rfc8693.html>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExchangeTokenRequest {
    /// required - urn:ietf:params:oauth:grant-type:token-exchange
    #[prost(string, tag="1")]
    pub grant_type: ::prost::alloc::string::String,
    /// optional type of requested token, default is urn:ietf:params:oauth:token-type:access_token
    #[prost(string, tag="2")]
    pub requested_token_type: ::prost::alloc::string::String,
    /// required - could be self signed JWT token
    #[prost(string, tag="3")]
    pub subject_token: ::prost::alloc::string::String,
    /// required, in case of jwt - urn:ietf:params:oauth:token-type:jwt
    #[prost(string, tag="4")]
    pub subject_token_type: ::prost::alloc::string::String,
    /// optional (scopes of the token)
    #[prost(string, repeated, tag="5")]
    pub scopes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// optional, name of the oauth client id on which this token will be used
    #[prost(string, tag="6")]
    pub audience: ::prost::alloc::string::String,
    /// optional, subject token for impersonation/delegation (who want to impersonate/delegate) in subject_token.
    #[prost(string, tag="7")]
    pub actor_token: ::prost::alloc::string::String,
    /// optional, token type for the impersonation/delegation (who want to impersonate/delegate). Usually it's urn:ietf:params:oauth:token-type:access_token
    #[prost(string, tag="8")]
    pub actor_token_type: ::prost::alloc::string::String,
    /// optional, list of resources approved to use by token, if applicable
    #[prost(string, repeated, tag="9")]
    pub resource: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTokenResponse {
    /// required
    #[prost(string, tag="1")]
    pub access_token: ::prost::alloc::string::String,
    /// required
    #[prost(string, tag="2")]
    pub issued_token_type: ::prost::alloc::string::String,
    /// required - Bearer
    #[prost(string, tag="3")]
    pub token_type: ::prost::alloc::string::String,
    #[prost(int64, tag="4")]
    pub expires_in: i64,
    #[prost(string, repeated, tag="5")]
    pub scopes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
include!("nebius.iam.v1.serde.rs");
include!("nebius.iam.v1.tonic.rs");
// @@protoc_insertion_point(module)