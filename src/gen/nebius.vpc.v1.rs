// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Pool {
    /// Metadata associated with the Pool.
    /// `metadata.parent_id` represents the Project.
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    /// Specification of the Pool.
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<PoolSpec>,
    /// Status information for the Pool.
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<PoolStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PoolSpec {
    /// ID of source pool. Current pool will be created with the same scope.
    /// Pool is a root-pool if this field is empty
    #[prost(string, tag="1")]
    pub source_pool_id: ::prost::alloc::string::String,
    /// IP version for the Pool.
    #[prost(enumeration="IpVersion", tag="3")]
    pub version: i32,
    #[prost(enumeration="IpVisibility", tag="5")]
    pub visibility: i32,
    /// CIDR blocks.
    #[prost(message, repeated, tag="4")]
    pub cidrs: ::prost::alloc::vec::Vec<PoolCidr>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PoolCidr {
    /// CIDR block.
    /// May be a prefix length (such as /24) for non-top-level pools
    /// or a CIDR-formatted string (such as 10.1.2.0/24).
    #[prost(string, tag="1")]
    pub cidr: ::prost::alloc::string::String,
    /// State of the Cidr.
    /// Default state is AVAILABLE
    #[prost(enumeration="AddressBlockState", tag="2")]
    pub state: i32,
    /// Maximum mask length for allocation from this cidr including creation of sub-pools
    /// Default max_mask_length is 32 for IPv4 and 128 for IPv6
    #[prost(int64, tag="3")]
    pub max_mask_length: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PoolStatus {
    /// Current state of the Pool.
    #[prost(enumeration="pool_status::State", tag="1")]
    pub state: i32,
    /// CIDR blocks.
    #[prost(string, repeated, tag="2")]
    pub cidrs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Scope is the unique identifier for single pool tree.
    #[prost(string, tag="3")]
    pub scope_id: ::prost::alloc::string::String,
    /// Assignment details for this Pool
    #[prost(message, optional, tag="4")]
    pub assignment: ::core::option::Option<PoolAssignment>,
}
/// Nested message and enum types in `PoolStatus`.
pub mod pool_status {
    /// Possible states of the Pool.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        /// Default, unspecified state.
        Unspecified = 0,
        /// Pool is being created.
        Creating = 1,
        /// Pool is ready for use.
        Ready = 2,
        /// Pool is being deleted.
        Deleting = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Ready => "READY",
                State::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "READY" => Some(Self::Ready),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PoolAssignment {
    /// IDs of Networks to which the Pool is assigned.
    #[prost(string, repeated, tag="1")]
    pub networks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// IDs of Subnets to which the Pool is assigned.
    #[prost(string, repeated, tag="2")]
    pub subnets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AddressBlockState {
    /// Default, unspecified state.
    StateUnspecified = 0,
    /// Allocation from range is available.
    Available = 1,
    /// New allocation would not be created.
    Disabled = 2,
}
impl AddressBlockState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AddressBlockState::StateUnspecified => "STATE_UNSPECIFIED",
            AddressBlockState::Available => "AVAILABLE",
            AddressBlockState::Disabled => "DISABLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATE_UNSPECIFIED" => Some(Self::StateUnspecified),
            "AVAILABLE" => Some(Self::Available),
            "DISABLED" => Some(Self::Disabled),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IpVersion {
    /// Default, unspecified IP version.
    Unspecified = 0,
    /// IPv4 address.
    Ipv4 = 1,
    /// IPv6 address.
    Ipv6 = 2,
}
impl IpVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            IpVersion::Unspecified => "IP_VERSION_UNSPECIFIED",
            IpVersion::Ipv4 => "IPV4",
            IpVersion::Ipv6 => "IPV6",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IP_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
            "IPV4" => Some(Self::Ipv4),
            "IPV6" => Some(Self::Ipv6),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IpVisibility {
    /// Default, unspecified IP visibility.
    Unspecified = 0,
    /// Private address.
    Private = 1,
    /// Public address.
    Public = 2,
}
impl IpVisibility {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            IpVisibility::Unspecified => "IP_VISIBILITY_UNSPECIFIED",
            IpVisibility::Private => "PRIVATE",
            IpVisibility::Public => "PUBLIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IP_VISIBILITY_UNSPECIFIED" => Some(Self::Unspecified),
            "PRIVATE" => Some(Self::Private),
            "PUBLIC" => Some(Self::Public),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Allocation {
    /// Metadata for the Allocation.
    /// `metadata.parent_id` represents IAM Container.
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    /// Specifications for the allocation, detailing its name and IP configuration.
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<AllocationSpec>,
    /// Contains the current status of the allocation, indicating its state and any additional details.
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<AllocationStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationSpec {
    /// Holds the IP specifications for the allocation, including the type of IP (IPv4 or IPv6) and its corresponding configuration.
    #[prost(oneof="allocation_spec::IpSpec", tags="1, 2")]
    pub ip_spec: ::core::option::Option<allocation_spec::IpSpec>,
}
/// Nested message and enum types in `AllocationSpec`.
pub mod allocation_spec {
    /// Holds the IP specifications for the allocation, including the type of IP (IPv4 or IPv6) and its corresponding configuration.
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum IpSpec {
        #[prost(message, tag="1")]
        Ipv4Private(super::IPv4PrivateAllocationSpec),
        #[prost(message, tag="2")]
        Ipv4Public(super::IPv4PublicAllocationSpec),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IPv4PrivateAllocationSpec {
    /// CIDR block for IPv4 Allocation.
    /// May be a single IP address (such as 10.2.3.4),
    /// a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
    /// Random address (/32) from pool would be allocated if field is omitted.
    #[prost(string, tag="1")]
    pub cidr: ::prost::alloc::string::String,
    #[prost(oneof="i_pv4_private_allocation_spec::Pool", tags="2, 3")]
    pub pool: ::core::option::Option<i_pv4_private_allocation_spec::Pool>,
}
/// Nested message and enum types in `IPv4PrivateAllocationSpec`.
pub mod i_pv4_private_allocation_spec {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Pool {
        /// Subnet ID.
        /// Required same subnet to use allocation in subnet-resources (e.g. Network Interface)
        #[prost(string, tag="2")]
        SubnetId(::prost::alloc::string::String),
        /// Pool for the IPv4 private allocation.
        #[prost(string, tag="3")]
        PoolId(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IPv4PublicAllocationSpec {
    /// CIDR block for IPv4 Allocation.
    /// May be a single IP address (such as 10.2.3.4),
    /// a prefix length (such as /32) or a CIDR-formatted string (such as 10.1.2.0/32).
    /// Random address (/32) from pool would be allocated if field is omitted.
    #[prost(string, tag="1")]
    pub cidr: ::prost::alloc::string::String,
    #[prost(oneof="i_pv4_public_allocation_spec::Pool", tags="2, 3")]
    pub pool: ::core::option::Option<i_pv4_public_allocation_spec::Pool>,
}
/// Nested message and enum types in `IPv4PublicAllocationSpec`.
pub mod i_pv4_public_allocation_spec {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Pool {
        /// Subnet ID.
        /// Required same subnet to use allocation in subnet-resources (e.g. Network Interface)
        #[prost(string, tag="2")]
        SubnetId(::prost::alloc::string::String),
        /// Pool for the IPv4 public allocation.
        #[prost(string, tag="3")]
        PoolId(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationStatus {
    /// This field represents the current state of the allocation.
    #[prost(enumeration="allocation_status::State", tag="1")]
    pub state: i32,
    /// Detailed information about the allocation status,
    /// including the allocated CIDR, pool ID and IP version.
    #[prost(message, optional, tag="2")]
    pub details: ::core::option::Option<AllocationDetails>,
    /// Information about the assignment associated with the allocation,
    /// such as network interface or load balancer assignment.
    #[prost(message, optional, tag="3")]
    pub assignment: ::core::option::Option<Assignment>,
    /// If false - Lifecycle of allocation depends on resource that using it.
    #[prost(bool, tag="4")]
    pub r#static: bool,
}
/// Nested message and enum types in `AllocationStatus`.
pub mod allocation_status {
    /// Enumeration of possible states of the Allocation.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        /// Default state, unspecified.
        Unspecified = 0,
        /// Allocation is being created.
        Creating = 1,
        /// Allocation is ready for use.
        Allocated = 2,
        /// Allocation is used.
        Assigned = 3,
        /// Allocation is being deleted.
        Deleting = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Allocated => "ALLOCATED",
                State::Assigned => "ASSIGNED",
                State::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ALLOCATED" => Some(Self::Allocated),
                "ASSIGNED" => Some(Self::Assigned),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationDetails {
    /// The actual CIDR block that has been allocated.
    #[prost(string, tag="1")]
    pub allocated_cidr: ::prost::alloc::string::String,
    /// ID of the pool from which this allocation was made.
    #[prost(string, tag="2")]
    pub pool_id: ::prost::alloc::string::String,
    /// The IP version of this allocation (IPv4 or IPv6).
    #[prost(enumeration="IpVersion", tag="4")]
    pub version: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Assignment {
    /// This field specifies the type of assignment associated with the allocation,
    /// which could be a network interface or load balancer assignment.
    #[prost(oneof="assignment::Type", tags="1, 2")]
    pub r#type: ::core::option::Option<assignment::Type>,
}
/// Nested message and enum types in `Assignment`.
pub mod assignment {
    /// This field specifies the type of assignment associated with the allocation,
    /// which could be a network interface or load balancer assignment.
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag="1")]
        NetworkInterface(super::NetworkInterfaceAssignment),
        #[prost(message, tag="2")]
        LoadBalancer(super::LoadBalancerAssignment),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkInterfaceAssignment {
    /// ID of the Compute instance network interface belongs to.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    /// Network interface name
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadBalancerAssignment {
    /// ID of the Load Balancer.
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllocationRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllocationByNameRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAllocationsRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAllocationsByPoolRequest {
    #[prost(string, tag="1")]
    pub pool_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAllocationsResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Allocation>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAllocationRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<AllocationSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAllocationRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<AllocationSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAllocationRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
/// Defines a Network, which serves as a virtual representation of a traditional LAN
/// within a cloud environment.
/// Networks facilitate communication between subnets.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Network {
    /// Metadata for the network resource.
    /// `metadata.parent_id` represents IAM container
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    /// Specification of the network.
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<NetworkSpec>,
    /// Status of the network.
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<NetworkStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkSpec {
    /// Pools for private ipv4 addresses.
    /// Default private pools will be created if not specified.
    #[prost(message, optional, tag="1")]
    pub ipv4_private_pools: ::core::option::Option<IPv4PrivateNetworkPools>,
    /// Pools for public ipv4 addresses.
    /// Default public pool will be used if not specified.
    #[prost(message, optional, tag="2")]
    pub ipv4_public_pools: ::core::option::Option<IPv4PublicNetworkPools>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IPv4PrivateNetworkPools {
    #[prost(message, repeated, tag="1")]
    pub pools: ::prost::alloc::vec::Vec<NetworkPool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IPv4PublicNetworkPools {
    #[prost(message, repeated, tag="1")]
    pub pools: ::prost::alloc::vec::Vec<NetworkPool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkPool {
    /// ID of the IP address pool.
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NetworkStatus {
    /// Current state of the network.
    #[prost(enumeration="network_status::State", tag="1")]
    pub state: i32,
}
/// Nested message and enum types in `NetworkStatus`.
pub mod network_status {
    /// Enumeration of possible states of the network.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        /// Default state, unspecified.
        Unspecified = 0,
        /// Network is being created.
        Creating = 1,
        /// Network is ready for use.
        Ready = 2,
        /// Network is being deleted.
        Deleting = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Ready => "READY",
                State::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "READY" => Some(Self::Ready),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNetworkRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNetworkByNameRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNetworksRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNetworksResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Network>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNetworkRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<NetworkSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDefaultNetworkRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateNetworkRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<NetworkSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNetworkRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPoolRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPoolByNameRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPoolsRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPoolsBySourcePoolRequest {
    #[prost(string, tag="1")]
    pub pool_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPoolsResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Pool>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePoolRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<PoolSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePoolRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<PoolSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePoolRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
/// Defines a Subnet, a segment of a network used for more granular control and management.
/// Subnet uses pools to organize address space.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Subnet {
    /// Metadata for the subnet resource.
    /// `metadata.parent_id` represents IAM container
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    /// Specification of the subnet.
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<SubnetSpec>,
    /// Status of the subnet.
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<SubnetStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubnetSpec {
    /// Network ID.
    #[prost(string, tag="1")]
    pub network_id: ::prost::alloc::string::String,
    /// Pools for private ipv4 addresses.
    /// Default is 'use_network_pools = true'
    #[prost(message, optional, tag="2")]
    pub ipv4_private_pools: ::core::option::Option<IPv4PrivateSubnetPools>,
    /// Pools for public ipv4 addresses.
    /// Default is 'use_network_pools = true'
    #[prost(message, optional, tag="3")]
    pub ipv4_public_pools: ::core::option::Option<IPv4PublicSubnetPools>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IPv4PrivateSubnetPools {
    /// Pools for private ipv4 allocations in subnet
    /// Must be empty if 'use_network_pools = true'
    #[prost(message, repeated, tag="1")]
    pub pools: ::prost::alloc::vec::Vec<SubnetPool>,
    /// Allow using of private ipv4 pools which are specified in network
    /// Must be false if 'pools' is not empty
    #[prost(bool, tag="2")]
    pub use_network_pools: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IPv4PublicSubnetPools {
    /// Pools for public ipv4 allocations in subnet
    /// Must be empty if 'use_network_pools = true'
    #[prost(message, repeated, tag="1")]
    pub pools: ::prost::alloc::vec::Vec<SubnetPool>,
    /// Allow using of public ipv4 pools which are specified in network
    /// Must be false if 'pools' is not empty
    #[prost(bool, tag="2")]
    pub use_network_pools: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubnetPool {
    #[prost(message, repeated, tag="2")]
    pub cidrs: ::prost::alloc::vec::Vec<SubnetCidr>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubnetCidr {
    /// CIDR block.
    /// May be a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
    #[prost(string, tag="1")]
    pub cidr: ::prost::alloc::string::String,
    /// State of the Cidr.
    /// Default state is AVAILABLE
    #[prost(enumeration="AddressBlockState", tag="2")]
    pub state: i32,
    /// Maximum mask length for allocation from this cidr
    /// Default max_mask_length is 32 for IPv4 and 128 for IPv6
    #[prost(int64, tag="3")]
    pub max_mask_length: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubnetStatus {
    /// Current state of the subnet.
    #[prost(enumeration="subnet_status::State", tag="1")]
    pub state: i32,
    /// CIDR blocks.
    #[prost(string, repeated, tag="2")]
    pub ipv4_private_cidrs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// CIDR blocks.
    #[prost(string, repeated, tag="3")]
    pub ipv4_public_cidrs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `SubnetStatus`.
pub mod subnet_status {
    /// Enumeration of possible states of the subnet.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        /// Default state, unspecified.
        Unspecified = 0,
        /// Subnet is being created.
        Creating = 1,
        /// Subnet is ready for use.
        Ready = 2,
        /// Subnet is being deleted.
        Deleting = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Ready => "READY",
                State::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "READY" => Some(Self::Ready),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSubnetRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSubnetByNameRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubnetsRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubnetsByNetworkRequest {
    #[prost(string, tag="1")]
    pub network_id: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub page_size: i64,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubnetsResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Subnet>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSubnetRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<SubnetSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSubnetRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<SubnetSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSubnetRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
include!("nebius.vpc.v1.serde.rs");
include!("nebius.vpc.v1.tonic.rs");
// @@protoc_insertion_point(module)