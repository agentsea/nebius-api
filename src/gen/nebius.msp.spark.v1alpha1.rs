// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cluster {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<ClusterSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<ClusterStatus>,
}
/// Cluster specification
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterSpec {
    /// Description of the cluster.
    #[prost(string, optional, tag="1")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// Limits for the cluster
    #[prost(message, optional, tag="3")]
    pub limits: ::core::option::Option<Limits>,
    /// Password for Spark History server and Sessions.
    #[prost(message, optional, tag="4")]
    pub authorization: ::core::option::Option<Password>,
    /// ID of the user service account for accessing
    /// S3 buckets in the user project
    #[prost(string, tag="5")]
    pub service_account_id: ::prost::alloc::string::String,
    #[prost(string, tag="6")]
    pub network_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterStatus {
    /// Current phase (or stage) of the cluster.
    #[prost(enumeration="super::super::v1alpha1::cluster_status::Phase", tag="1")]
    pub phase: i32,
    /// State reflects substatus of the stage to define whether it's healthy or not.
    #[prost(enumeration="super::super::v1alpha1::cluster_status::State", tag="2")]
    pub state: i32,
    /// History Server WebUI endpoint
    #[prost(string, optional, tag="3")]
    pub history_server_endpoint: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Limits {
    #[prost(int64, tag="1")]
    pub cpu: i64,
    #[prost(int64, tag="2")]
    pub memory_gibibytes: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Password {
    #[prost(string, tag="1")]
    pub password: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetClusterRequest {
    /// ID of the cluster to retrieve.
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetClusterByNameRequest {
    /// Parent ID of the cluster to retrieve.
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// Name of the cluster to retrieve.
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListClustersRequest {
    /// Identifier of IAM container to list clusters from.
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// Specifies the maximum number of items to return in the response. Default value is 100.
    #[prost(int64, tag="2")]
    pub page_size: i64,
    /// Token for pagination, allowing the retrieval of the next set of results.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListClustersResponse {
    /// List of clusters.
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Cluster>,
    /// Token for pagination, indicating the next set of results can be retrieved using this token.
    #[prost(string, optional, tag="2")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateClusterRequest {
    /// Metadata associated with the new cluster. Must include parent_id in which we create the cluster.
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::super::common::v1::ResourceMetadata>,
    /// Specification for the new cluster.
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<ClusterSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateClusterRequest {
    /// Metadata associated with the cluster. Must include id of the cluster we are going to update.
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::super::common::v1::ResourceMetadata>,
    /// Updated specification for the cluster.
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<ClusterSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteClusterRequest {
    /// ID of the cluster to delete.
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PythonConfig {
    /// Python requirements
    #[prost(string, repeated, tag="1")]
    pub requirements: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// S3 URIs of files to be placed in PYTHONPATH of driver and executors for python applications (.py, .zip, .egg)
    #[prost(string, repeated, tag="2")]
    pub file_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JavaConfig {
    /// Entrypoint class for Java application
    #[prost(string, tag="1")]
    pub entrypoint_class: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DriverTemplateSpec {
    #[prost(message, optional, tag="3")]
    pub disk: ::core::option::Option<super::super::v1alpha1::resource::DiskSpec>,
    #[prost(message, optional, tag="4")]
    pub resources: ::core::option::Option<super::super::v1alpha1::resource::ResourcesSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DynamicAllocationSpec {
    #[prost(int64, tag="1")]
    pub min: i64,
    #[prost(int64, tag="2")]
    pub max: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutorTemplateSpec {
    #[prost(message, optional, tag="2")]
    pub disk: ::core::option::Option<super::super::v1alpha1::resource::DiskSpec>,
    #[prost(message, optional, tag="4")]
    pub resources: ::core::option::Option<super::super::v1alpha1::resource::ResourcesSpec>,
    #[prost(oneof="executor_template_spec::HostsSpec", tags="101, 102")]
    pub hosts_spec: ::core::option::Option<executor_template_spec::HostsSpec>,
}
/// Nested message and enum types in `ExecutorTemplateSpec`.
pub mod executor_template_spec {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum HostsSpec {
        #[prost(message, tag="101")]
        Hosts(super::super::super::v1alpha1::resource::HostSpec),
        #[prost(message, tag="102")]
        HostsDynamicAllocation(super::DynamicAllocationSpec),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Job {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<JobSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<JobStatus>,
}
/// Spark Job specification
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobSpec {
    /// Description of the job.
    #[prost(string, optional, tag="1")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// S3 URI of main application file
    /// Example: s3a://mybucket/myapp.py
    #[prost(string, tag="2")]
    pub application_file_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub driver: ::core::option::Option<DriverTemplateSpec>,
    #[prost(message, optional, tag="5")]
    pub executor: ::core::option::Option<ExecutorTemplateSpec>,
    #[prost(string, tag="6")]
    pub spark_version: ::prost::alloc::string::String,
    /// Application args
    #[prost(string, repeated, tag="101")]
    pub application_args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// S3 URIs of files to be placed in executor working directory
    #[prost(string, repeated, tag="102")]
    pub file_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// S3 URIs of Jars to be placed in classpaths of driver and executors for java applications
    #[prost(string, repeated, tag="103")]
    pub jar_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of maven coordinates of jars to include on the driver and executor classpaths
    #[prost(string, repeated, tag="104")]
    pub packages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Map of spark configuration parameters
    #[prost(map="string, string", tag="105")]
    pub spark_conf: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Runtime-specific job config
    #[prost(oneof="job_spec::RuntimeConfig", tags="201, 202")]
    pub runtime_config: ::core::option::Option<job_spec::RuntimeConfig>,
}
/// Nested message and enum types in `JobSpec`.
pub mod job_spec {
    /// Runtime-specific job config
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RuntimeConfig {
        #[prost(message, tag="201")]
        Python(super::PythonConfig),
        #[prost(message, tag="202")]
        Java(super::JavaConfig),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JobResultDetails {
    /// Result code
    #[prost(enumeration="JobResultCode", tag="1")]
    pub code: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobStatus {
    /// Current phase (or stage) of the cluster.
    #[prost(enumeration="super::super::v1alpha1::cluster_status::Phase", tag="1")]
    pub phase: i32,
    /// State reflects substatus of the stage to define whether it's healthy or not.
    #[prost(enumeration="super::super::v1alpha1::cluster_status::State", tag="2")]
    pub state: i32,
    /// Job Driver Web UI endpoint
    #[prost(string, optional, tag="3")]
    pub driver_endpoint: ::core::option::Option<::prost::alloc::string::String>,
    /// Job driver resource preset details
    #[prost(message, optional, tag="4")]
    pub driver_preset_details: ::core::option::Option<super::super::v1alpha1::resource::PresetDetails>,
    /// Job executor resource preset details
    #[prost(message, optional, tag="5")]
    pub executor_preset_details: ::core::option::Option<super::super::v1alpha1::resource::PresetDetails>,
    /// Job execution result details
    #[prost(message, optional, tag="6")]
    pub result_details: ::core::option::Option<JobResultDetails>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JobResultCode {
    Unspecified = 0,
    Succeeded = 1,
    Error = 2,
}
impl JobResultCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            JobResultCode::Unspecified => "JOB_RESULT_CODE_UNSPECIFIED",
            JobResultCode::Succeeded => "SUCCEEDED",
            JobResultCode::Error => "ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "JOB_RESULT_CODE_UNSPECIFIED" => Some(Self::Unspecified),
            "SUCCEEDED" => Some(Self::Succeeded),
            "ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetJobRequest {
    /// ID of the job to retrieve.
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobsRequest {
    /// Identifier of IAM container to list jobs from.
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// Specifies the maximum number of items to return in the response. Default value is 100.
    #[prost(int64, tag="2")]
    pub page_size: i64,
    /// Token for pagination, allowing the retrieval of the next set of results.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobsResponse {
    /// List of jobs.
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Job>,
    /// Token for pagination, indicating the next set of results can be retrieved using this token.
    #[prost(string, optional, tag="2")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateJobRequest {
    /// Metadata associated with the new job. Must include parent_id - ID of the cluster to create job in.
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::super::common::v1::ResourceMetadata>,
    /// Specification for the new job.
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<JobSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelJobRequest {
    /// ID of the job to cancel.
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Session {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<SessionSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<SessionStatus>,
}
/// Spark Session specification
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionSpec {
    /// Description of the session.
    #[prost(string, optional, tag="1")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="2")]
    pub driver: ::core::option::Option<DriverTemplateSpec>,
    #[prost(message, optional, tag="3")]
    pub executor: ::core::option::Option<ExecutorTemplateSpec>,
    #[prost(string, tag="4")]
    pub spark_version: ::prost::alloc::string::String,
    /// S3 URIs of files to be placed in executor working directory
    #[prost(string, repeated, tag="101")]
    pub file_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// S3 URIs of Jars to be placed in classpaths of driver and executors for java applications
    #[prost(string, repeated, tag="102")]
    pub jar_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of maven coordinates of jars to include on the driver and executor classpaths
    #[prost(string, repeated, tag="103")]
    pub packages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Map of spark configuration parameters
    #[prost(map="string, string", tag="104")]
    pub spark_conf: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Python runtime-specific session config
    #[prost(message, optional, tag="201")]
    pub python: ::core::option::Option<PythonConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionStatus {
    /// Current phase (or stage) of the cluster.
    #[prost(enumeration="super::super::v1alpha1::cluster_status::Phase", tag="1")]
    pub phase: i32,
    /// State reflects substatus of the stage to define whether it's healthy or not.
    #[prost(enumeration="super::super::v1alpha1::cluster_status::State", tag="2")]
    pub state: i32,
    /// Spark Connect endpoint
    #[prost(string, optional, tag="3")]
    pub spark_connect_endpoint: ::core::option::Option<::prost::alloc::string::String>,
    /// Session driver resource preset details
    #[prost(message, optional, tag="4")]
    pub driver_preset_details: ::core::option::Option<super::super::v1alpha1::resource::PresetDetails>,
    /// Session executor resource preset details
    #[prost(message, optional, tag="5")]
    pub executor_preset_details: ::core::option::Option<super::super::v1alpha1::resource::PresetDetails>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSessionRequest {
    /// ID of the session to retrieve.
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSessionByNameRequest {
    /// Parent ID of the session to retrieve.
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// Name of the session to retrieve.
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSessionsRequest {
    /// Identifier of IAM container to list sessions from.
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// Specifies the maximum number of items to return in the response. Default value is 100.
    #[prost(int64, tag="2")]
    pub page_size: i64,
    /// Token for pagination, allowing the retrieval of the next set of results.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSessionsResponse {
    /// List of sessions.
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Session>,
    /// Token for pagination, indicating the next set of results can be retrieved using this token.
    #[prost(string, optional, tag="2")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSessionRequest {
    /// Metadata associated with the new session. Must include parent_id - ID of the cluster to create session in.
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::super::common::v1::ResourceMetadata>,
    /// Specification for the new session.
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<SessionSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSessionRequest {
    /// ID of the session to delete.
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
include!("nebius.msp.spark.v1alpha1.serde.rs");
include!("nebius.msp.spark.v1alpha1.tonic.rs");
// @@protoc_insertion_point(module)