// @generated
// This file is @generated by prost-build.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StorageClass {
    Unspecified = 0,
    Standard = 1,
    EnhancedThroughput = 2,
}
impl StorageClass {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            StorageClass::Unspecified => "STORAGE_CLASS_UNSPECIFIED",
            StorageClass::Standard => "STANDARD",
            StorageClass::EnhancedThroughput => "ENHANCED_THROUGHPUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STORAGE_CLASS_UNSPECIFIED" => Some(Self::Unspecified),
            "STANDARD" => Some(Self::Standard),
            "ENHANCED_THROUGHPUT" => Some(Self::EnhancedThroughput),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VersioningPolicy {
    Unspecified = 0,
    Disabled = 1,
    Enabled = 2,
    Suspended = 3,
}
impl VersioningPolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            VersioningPolicy::Unspecified => "VERSIONING_POLICY_UNSPECIFIED",
            VersioningPolicy::Disabled => "DISABLED",
            VersioningPolicy::Enabled => "ENABLED",
            VersioningPolicy::Suspended => "SUSPENDED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VERSIONING_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
            "DISABLED" => Some(Self::Disabled),
            "ENABLED" => Some(Self::Enabled),
            "SUSPENDED" => Some(Self::Suspended),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CurrentBucketCounters {
    #[prost(int64, tag="1")]
    pub simple_objects_quantity: i64,
    #[prost(int64, tag="2")]
    pub simple_objects_size: i64,
    #[prost(int64, tag="3")]
    pub multipart_objects_quantity: i64,
    #[prost(int64, tag="4")]
    pub multipart_objects_size: i64,
    #[prost(int64, tag="5")]
    pub multipart_uploads_quantity: i64,
    #[prost(int64, tag="6")]
    pub inflight_parts_quantity: i64,
    #[prost(int64, tag="7")]
    pub inflight_parts_size: i64,
}
/// Counters for non-current object versions (for versioning buckets).
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NonCurrentBucketCounters {
    #[prost(int64, tag="1")]
    pub simple_objects_quantity: i64,
    #[prost(int64, tag="2")]
    pub simple_objects_size: i64,
    #[prost(int64, tag="3")]
    pub multipart_objects_quantity: i64,
    #[prost(int64, tag="4")]
    pub multipart_objects_size: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BucketCounters {
    #[prost(enumeration="StorageClass", tag="1")]
    pub storage_class: i32,
    #[prost(message, optional, tag="2")]
    pub counters: ::core::option::Option<CurrentBucketCounters>,
    #[prost(message, optional, tag="3")]
    pub non_current_counters: ::core::option::Option<NonCurrentBucketCounters>,
}
/// The lifecycle configuration consists of one or more rules.
/// An Lifecycle configuration can have up to 1,000 rules.
/// Each rule consists of the following:
/// - A filter identifying a subset of objects to which the rule applies.
///    The filter can be based on a key name prefix, object size, or any combination of these.
/// - A status indicating whether the rule is currently active.
/// - One or more lifecycle expiration actions that you want to be performed on the objects
///    identified by the filter. If the state of your bucket is versioning-enabled or versioning-suspended
///    (bucket.spec.versioning_policy equals to ENABLED or SUSPENDED) you can have many versions of the same
///    object (one current version and zero or more noncurrent versions). The system provides predefined actions
///    that you can specify for current and noncurrent object versions.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LifecycleConfiguration {
    #[prost(message, repeated, tag="1")]
    pub rules: ::prost::alloc::vec::Vec<LifecycleRule>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LifecycleRule {
    /// Unique identifier for the rule per configuration.
    /// The value cannot be longer than 255 characters.
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration="lifecycle_rule::Status", tag="2")]
    pub status: i32,
    /// The Filter is used to identify objects that a Lifecycle Rule applies to.
    /// The Lifecycle Rule will apply to any object matching all of the predicates
    /// configured inside (using logical AND).
    #[prost(message, optional, tag="3")]
    pub filter: ::core::option::Option<LifecycleFilter>,
    /// Specifies the expiration for the lifecycle of the object in the form of date, days and,
    /// whether the object has a delete marker.
    #[prost(message, optional, tag="4")]
    pub expiration: ::core::option::Option<LifecycleExpiration>,
    /// Specifies when noncurrent object versions expire.
    /// It works only on a bucket that has versioning enabled (or suspended).
    #[prost(message, optional, tag="5")]
    pub noncurrent_version_expiration: ::core::option::Option<LifecycleNoncurrentVersionExpiration>,
    /// Specifies the days since the initiation of an incomplete multipart upload that
    /// the system will wait before permanently removing all parts of the upload.
    #[prost(message, optional, tag="6")]
    pub abort_incomplete_multipart_upload: ::core::option::Option<LifecycleAbortIncompleteMultipartUpload>,
}
/// Nested message and enum types in `LifecycleRule`.
pub mod lifecycle_rule {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        Enabled = 1,
        Disabled = 2,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::Unspecified => "STATUS_UNSPECIFIED",
                Status::Enabled => "ENABLED",
                Status::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "ENABLED" => Some(Self::Enabled),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LifecycleFilter {
    /// Prefix identifying one or more objects to which the rule applies.
    /// If prefix is empty, the rule applies to all objects in the bucket.
    #[prost(string, tag="1")]
    pub prefix: ::prost::alloc::string::String,
    /// Minimum object size to which the rule applies.
    #[prost(int64, tag="2")]
    pub object_size_greater_than_bytes: i64,
    /// Maximum object size to which the rule applies.
    #[prost(int64, tag="3")]
    pub object_size_less_than_bytes: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LifecycleExpiration {
    /// Indicates whether the system will remove a "delete marker" with no noncurrent versions.
    /// If set to true, the "delete marker" will be permanently removed.
    /// If set to false the policy takes no action.
    /// This cannot be specified with Days or Date in a LifecycleExpiration Policy.
    #[prost(bool, tag="3")]
    pub expired_object_delete_marker: bool,
    #[prost(oneof="lifecycle_expiration::ExpiredWith", tags="1, 2")]
    pub expired_with: ::core::option::Option<lifecycle_expiration::ExpiredWith>,
}
/// Nested message and enum types in `LifecycleExpiration`.
pub mod lifecycle_expiration {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ExpiredWith {
        /// Indicates at what date the object will be deleted. The time is always midnight UTC.
        #[prost(message, tag="1")]
        Date(::pbjson_types::Timestamp),
        /// Indicates the lifetime, in days, of the objects that are subject to the rule.
        /// The value must be a non-zero positive integer.
        #[prost(int32, tag="2")]
        Days(i32),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LifecycleNoncurrentVersionExpiration {
    /// Specifies how many noncurrent versions the system will retain.
    #[prost(int32, optional, tag="1")]
    pub newer_noncurrent_versions: ::core::option::Option<i32>,
    /// Specifies the number of days an object is noncurrent before the system will expire it.
    #[prost(int32, tag="2")]
    pub noncurrent_days: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LifecycleAbortIncompleteMultipartUpload {
    /// Specifies the days since the initiation of an incomplete multipart upload that
    /// the system will wait before permanently removing all parts of the upload.
    #[prost(int32, tag="1")]
    pub days_after_initiation: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bucket {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<BucketSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<BucketStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BucketSpec {
    /// Supports transitions:
    ///   * disabled -> enabled
    ///   * disabled -> suspended
    ///   * enabled <-> suspended
    #[prost(enumeration="VersioningPolicy", tag="2")]
    pub versioning_policy: i32,
    /// Maximum bucket size.
    /// Zero means unlimited.
    /// Actual limit can be lower if customer doesn't have enough quota.
    /// Real bucket size can go a little higher if customer writes too fast.
    #[prost(int64, tag="4")]
    pub max_size_bytes: i64,
    #[prost(message, optional, tag="5")]
    pub lifecycle_configuration: ::core::option::Option<LifecycleConfiguration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BucketStatus {
    #[prost(message, repeated, tag="1")]
    pub counters: ::prost::alloc::vec::Vec<BucketCounters>,
    #[prost(enumeration="bucket_status::State", tag="2")]
    pub state: i32,
    #[prost(enumeration="bucket_status::SuspensionState", tag="3")]
    pub suspension_state: i32,
    /// The time when the bucket was deleted (or scheduled for deletion).
    /// It resets to null if the bucket is undeleted.
    #[prost(message, optional, tag="4")]
    pub deleted_at: ::core::option::Option<::pbjson_types::Timestamp>,
    /// The time when the bucket will be automatically purged in case it was soft-deleted.
    #[prost(message, optional, tag="5")]
    pub purge_at: ::core::option::Option<::pbjson_types::Timestamp>,
    /// The domain of the endpoint where the bucket can be accessed. It omits the scheme (HTTPS) and the port (443)
    /// and contains only the FQDN address.
    #[prost(string, tag="6")]
    pub domain_name: ::prost::alloc::string::String,
    /// The name of the region where the bucket is located for use with S3 clients, i.e. "eu-west1".
    #[prost(string, tag="8")]
    pub region: ::prost::alloc::string::String,
}
/// Nested message and enum types in `BucketStatus`.
pub mod bucket_status {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        /// Bucket is under creation and cannot be used yet.
        Creating = 1,
        /// Bucket is active and ready for usage.
        Active = 2,
        /// Bucket is being updated.
        /// It can be used, but some settings are being modified and you can observe their inconsistency.
        Updating = 3,
        /// Bucket is scheduled for deletion.
        /// It cannot be used in s3 api anymore.
        ScheduledForDeletion = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Active => "ACTIVE",
                State::Updating => "UPDATING",
                State::ScheduledForDeletion => "SCHEDULED_FOR_DELETION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "UPDATING" => Some(Self::Updating),
                "SCHEDULED_FOR_DELETION" => Some(Self::ScheduledForDeletion),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SuspensionState {
        Unspecified = 0,
        NotSuspended = 1,
        Suspended = 2,
    }
    impl SuspensionState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SuspensionState::Unspecified => "SUSPENSION_STATE_UNSPECIFIED",
                SuspensionState::NotSuspended => "NOT_SUSPENDED",
                SuspensionState::Suspended => "SUSPENDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SUSPENSION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "NOT_SUSPENDED" => Some(Self::NotSuspended),
                "SUSPENDED" => Some(Self::Suspended),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBucketRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBucketByNameRequest {
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBucketRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<BucketSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBucketRequest {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<super::super::common::v1::ResourceMetadata>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<BucketSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBucketRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    /// You can provide purge_at or ttl after which the bucket will be purged automatically.
    /// Otherwise, default ttl of 7 days will be applied.
    #[prost(oneof="delete_bucket_request::Purge", tags="3, 4")]
    pub purge: ::core::option::Option<delete_bucket_request::Purge>,
}
/// Nested message and enum types in `DeleteBucketRequest`.
pub mod delete_bucket_request {
    /// You can provide purge_at or ttl after which the bucket will be purged automatically.
    /// Otherwise, default ttl of 7 days will be applied.
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Purge {
        /// Absolute purging time: status.purge_at will be set to this value.
        #[prost(message, tag="3")]
        PurgeAt(::pbjson_types::Timestamp),
        /// Relative purging time: status.purge_at will be set to (current timestamp + ttl).
        #[prost(message, tag="4")]
        Ttl(::pbjson_types::Duration),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeBucketRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeleteBucketRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBucketsRequest {
    /// Represents the container ID.
    #[prost(string, tag="1")]
    pub parent_id: ::prost::alloc::string::String,
    /// Specifies the maximum number of items to return in the response.
    #[prost(int64, tag="2")]
    pub page_size: i64,
    /// Token for pagination, allowing the retrieval of the next set of results.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    /// A filter to narrow down the results based on specific criteria.
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBucketsResponse {
    /// List of buckets returned in the response. The field should be named as `items` for consistency.
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Bucket>,
    /// Token for pagination, indicating the next set of results can be retrieved using this token.
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
include!("nebius.storage.v1.serde.rs");
include!("nebius.storage.v1.tonic.rs");
// @@protoc_insertion_point(module)